read;
quiet on;

stats_r1M2 := 0		/* set read_CN := 1 and dcells := 1 to do stats */
rr1     := 0		/* set    rr1 := 1 to relax foam at r1 
	   		    with revised facet deletion before popping, with "r1_relax_foam" */
read_CN := 0		/*	1	read "cell_neighbors" */
dcells  := 0		/* set dcells := 1 to analyze cell statistics with "Von_Neumann" */
read_VA := 0		/*	1	read "vertex_angles" */
read_SF := 0		/*	1	read "shear_flow" */
	strain_shift := 0;
read_EA := 0		/*	1	read "evolver_to_ABAQUS" */
read_EAC := 0		/*	1	read "evolver_to_ABAQUS_cube" */
        if read_EA==1 or read_EAC==1 then B3i := 1;     /* 1,2,3 for ABAQUS beam elements B31,B32,B33 */
        if read_EA==1 or read_EAC==2 then B3i := 2;
        if read_EA==1 or read_EAC==3 then B3i := 3;
read_FA := 0		/*	1	read "face_areas" */
read_EL := 0		/*	1	read "edge_lengths" */
cell_vol := 5	/*	1	vol1
			2	polydisperse Voronoi structure
			3	equalvol
			4	avgvol1		"old vol1"
			5	polytargets	
			6	poly_vol1	*/

pcells  := 0		// set pcells := 1 to print individual cell statistics to stats.dat
ccells  := 0	 	// set ccells := 1 to count cell types with "Matzke_cells"
Matzke_files := 0	// set Matzke_files := 1 to print ctypes.dat, matzke_cell_stats.dat, and matzke_stats.dat
lanl    := 0		// set   lanl := 1 to generate LANL statistics
do_ub   := 0		// set  do_ub := 1 to do unstable_bodies
iprint  := 0

if stats_r1M2==1 then { read_CN := 1; dcells := 1 }; 
//if sum(body,old_target) == 0 then set body.target volume; 
if sum(body,old_target) == 0 and cell_vol != 1 then cell_vol := 2; 
if sum(body,old_target) != 0 and cell_vol == 2 then cell_vol := 5;
//cell_vol := 1

printf "\n cell_vol = %g\n\n", cell_vol;

// The following define matrices that modify 
// torus periods and vertex positions to stretch, shear or rotate the foam

	// variables needed for the matrix calcs
define vertex attribute tx real;
define vertex attribute ty real;
define vertex attribute tz real;
define vertex attribute edge_len real;

nndmp := 0;

initmat := {
	mxx:=1; mxy:=0; mxz:=0;
	myx:=0; myy:=1; myz:=0;
	mzx:=0; mzy:=0; mzz:=1;
	xstr:=1; ystr:=1; zstr:=1;
	xyshr:=0; yzshr:=0; zxshr:=0;
	phi:=0; theta:=0; psi:=0 }

applymat := {
	tp1x:=p1x*mxx+p1y*mxy+p1z*mxz;
	tp1y:=p1x*myx+p1y*myy+p1z*myz;
	tp1z:=p1x*mzx+p1y*mzy+p1z*mzz;
	tp2x:=p2x*mxx+p2y*mxy+p2z*mxz;
	tp2y:=p2x*myx+p2y*myy+p2z*myz;
	tp2z:=p2x*mzx+p2y*mzy+p2z*mzz;
	tp3x:=p3x*mxx+p3y*mxy+p3z*mxz;
	tp3y:=p3x*myx+p3y*myy+p3z*myz;
	tp3z:=p3x*mzx+p3y*mzy+p3z*mzz;
	p1x:=tp1x; p1y:=tp1y; p1z:=tp1z;
	p2x:=tp2x; p2y:=tp2y; p2z:=tp2z;
	p3x:=tp3x; p3y:=tp3y; p3z:=tp3z;
	// det:=mxx*myy*mzz-mxz*myy*mzx+myx*mzy*mxz-myz*mzy*mxx+mzx*mxy*myz-mzz*mxy*myx;
	set vertex tx x*mxx+y*mxy+z*mxz;
	set vertex ty x*myx+y*myy+z*myz;
	set vertex tz x*mzx+y*mzy+z*mzz;
	set vertex x tx; set vertex y ty; set vertex z tz; recalc }

	// after setting the three stretches, do strmat to apply them
strmat := {
	mxx:=xstr; myy:=ystr; mzz:=zstr;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// after setting the shears, do shrmat to apply them
shrmat := {
	mxx:=1; myy:=1; mzz:=1;
	mxy:=xyshr; myz:=yzshr; mzx:=zxshr; myx:=0; mzy:=0; mxz:=0; applymat }

	// after setting the three euler angles, do rotmat to apply them
	// counterclockwise rotation through an angle phi about z-axis
	// counterclockwise rotation through an angle theta about y-axis
	// counterclockwise rotation through an angle psi about z-axis
rotmat := {
	mxx :=  Cos(phi)*Cos(psi)*Cos(theta)-Sin(phi)*Sin(psi);
	mxy := -Sin(phi)*Cos(psi)*Cos(theta)-Cos(phi)*Sin(psi);
	mxz :=  Cos(psi)*Sin(theta);
	myx :=  Sin(phi)*Cos(psi)+Cos(theta)*Cos(phi)*Sin(psi);
	myy :=  Cos(phi)*Cos(psi)-Cos(theta)*Sin(phi)*Sin(psi);
	myz :=  Sin(psi)*Sin(theta);
	mzx := -Cos(phi)*Sin(theta);
	mzy :=  Sin(phi)*Sin(theta);
	mzz :=  Cos(theta); applymat }

	// homothetically stretch to make the average cell volume equal one
avgvol1 := {
	mxx:=1/(sum(body,volume)/body_count)^(1/3); myy:=mxx; mzz:=mxx;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

//	set all volume targets equal
equalvol := { set body target sum(body,volume)/body_count; unset body[1] target }

//	set all cell volumes equal one
vol1_old := {
	mxx:=1/(sum(body,volume)/body_count)^(1/3); myy:=mxx; mzz:=mxx;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat; equalvol }

vol1 := {
	mxx:=1/(sum(body,volume)/body_count)^(1/3); myy:=mxx; mzz:=mxx;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat; 
	set body target 1; unset body[1] target }

//	set avg cell volume = 1 for coarsened system

//	set_poly_vol1_targets := { reduce := sum(body,1)/sum(body,volume); 
//	set body target reduce*old_target }

poly_vol1 := {reduce := sum(body,1)/sum(body,volume); 
	mxx:=1/(sum(body,volume)/body_count)^(1/3); myy:=mxx; mzz:=mxx;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat; 
	set body target reduce*old_target; 
	set body old_target target  }

connected;
initmat;
optimize 500;

//remember to change the stain
e_scale_tol := 0.01;
strain_set := 0;

polydisperse := { set body.target volume; unset body[1] target }

// polytargets := { set body.target old_target; unset body[1] target }
polytargets := { set body.target old_target; 
unset_bb_target := 1; 
foreach body bb do { if unset_bb_target == 1 then { unset bb target; unset_bb_target := 0 }; }; }

if cell_vol == 1 then vol1;
if cell_vol == 2 then polydisperse;
if cell_vol == 3 then equalvol;
if cell_vol == 4 then avgvol1;		// "old vol1"
if cell_vol == 5 then polytargets;
if cell_vol == 6 then poly_vol1;

foreach body bb where old_target == 0 do set bb.old_target sum(body,volume) - sum(body where id != bb.id,old_target); 

fec := {set facet color 11; set edge color black}

//define body attribute bbf0  integer;
//define body attribute bbf   integer;
define body attribute bbf0  real;
define body attribute bbf   real;
define body attribute Rk REAL;

set_bbf := { unb := 0; printf "\n"; 
	foreach body bb do { 
	bbfaces:=((sum(bb.facet,1)+12)/6 + sum( bb.facet ff where
	ff.edge[1].valence>=3 and ff.edge[2].valence>=3 and
	ff.edge[3].valence>=3,1)/3);
	if floor(bbfaces) != ceil(bbfaces) then { 
	if unb==0 then 
	printf "There are problems with the following bodies:\n"; 
	printf "  %g", bb.id; 
		bbfaces := 0; 
	unb := unb + 1 }; 
	set bb.bbf bbfaces }; 
	if unb > 0 then printf "\n\n" };

F_stats := { set_bbf; 
// set body[1].target sum(body,volume) - sum(body where id != 1,target); 
foreach body bb where target == 0 do set bb.target sum(body,volume) - sum(body where id != bb.id,target); 
volbar := sum(body,volume)/body_count;
// volmu2 := sum(body, (target-volbar)^2 )/body_count;
volmu2 := sum(body, (volume-volbar)^2 )/body_count;
volsigma := sqrt(volmu2);
// foreach body bb do { set bb.Rk ((3*bb.target)/(4*Pi))^(1/3) };
foreach body bb do { set bb.Rk ((3*bb.volume)/(4*Pi))^(1/3) };
rbar := sum(body, Rk)/body_count;
R21  := sum(body, Rk^2)/sum(body, Rk);
R32  := sum(body, Rk^3)/sum(body, Rk^2);

R0   := (sum(body, Rk^3)/sum(body, 1))^(1/3); 

// R0   := (3/(4*Pi))^(1/3);

epsilon := abs(R32/R0-1);
rmu2 := sum(body, (Rk - rbar)^2 )/body_count;
rsigma := sqrt(rmu2);
Fbar := sum(body,bbf)/body_count;
Fmu2 := sum(body,(bbf-Fbar)^2)/body_count;

      printf "\n           p = %8.6f  (R32/R0-1)\n", epsilon;
        printf " Fmu2/Fbar^2 = %8.6f\n", Fmu2/Fbar^2;
	printf " Rsigma/Rbar = %8.6f\n\n", rsigma/rbar;

	printf "     Fbar = %8.6f\n", Fbar;
	printf "     Fmu2 = %8.6f\n", Fmu2;
	printf "     Rbar = %8.6f\n", rbar;
	printf "   Rsigma = %8.6f\n", rsigma;
	printf "      R32 = %8.6f\n", R32;
	printf "   volbar = %8.6f\n", volbar;
	printf "   volmu2 = %8.6f\n", volmu2;
	printf " volsigma = %8.6f\n", volsigma;
	printf "      R21 = %8.6f\n", R21;
	printf "     Rmu2 = %8.6f\n", rmu2;
// unset body[1].target; 
unset_bb_target := 1; 
foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; }; 
printf "\n   *** F_stats uses actual body volumes ***\n"
};

F_stats_targets := { // set_bbf;
same_structure := 0; 
// set body[1].target sum(body,volume) - sum(body where id != 1,target);
// foreach body bb where target == 0 do set bb.target sum(body,volume) - sum(body where id != bb.id,target);
volumefactor := sum(body, volume)/sum(body, 4*pi*radius^3/3);
foreach body bb do set bb.target volumefactor*4*pi*bb.radius^3/3;
volbar := sum(body,target)/body_count;
volmu2 := sum(body, (target-volbar)^2 )/body_count;
// volmu2 := sum(body, (volume-volbar)^2 )/body_count;
volsigma := sqrt(volmu2);
foreach body bb do { set bb.Rk ((3*bb.target)/(4*Pi))^(1/3) };
// foreach body bb do { set bb.Rk ((3*bb.volume)/(4*Pi))^(1/3) };
rbar := sum(body, Rk)/body_count;
R21  := sum(body, Rk^2)/sum(body, Rk);
R32  := sum(body, Rk^3)/sum(body, Rk^2);
R0   := (sum(body, Rk^3)/sum(body, 1))^(1/3);
epsilon := abs(R32/R0-1);
rmu2 := sum(body, (Rk - rbar)^2 )/body_count;
rsigma := sqrt(rmu2);
Fbar := sum(body,bbf)/body_count;
Fmu2 := sum(body,(bbf-Fbar)^2)/body_count;

      printf "\n           p = %8.6f  (R32/R0-1)\n", epsilon;
        printf " Fmu2/Fbar^2 = %8.6f\n", Fmu2/Fbar^2;
        printf " Rsigma/Rbar = %8.6f\n\n", rsigma/rbar;

        printf "     Fbar = %8.6f\n", Fbar;
        printf "     Fmu2 = %8.6f\n", Fmu2;
        printf "     Rbar = %8.6f\n", rbar;
        printf "   Rsigma = %8.6f\n", rsigma;
        printf "      R32 = %8.6f\n", R32;
        printf "   volbar = %8.6f\n", volbar;
        printf "   volmu2 = %8.6f\n", volmu2;
        printf " volsigma = %8.6f\n", volsigma;
        printf "      R21 = %8.6f\n", R21;
        printf "     Rmu2 = %8.6f\n", rmu2;
unset body[1].target;
// unset_bb_target := 1;
// foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; };
printf "\n   *** F_stats uses body targets ***\n"
};


F_stats_spheres := { // set_bbf;
define body attribute initial_volume_sp real;
define body attribute sphere_target real;
same_structure := 0;
volumefactor := sum(body, volume)/sum(body, 4*pi*radius^3/3);
foreach body bb do set bb.initial_volume_sp bb.volume;
foreach body bb do set bb.sphere_target volumefactor*4*pi*bb.radius^3/3;
volbar := sum(body,sphere_target)/body_count;
volmu2 := sum(body, (sphere_target-volbar)^2 )/body_count;
volsigma := sqrt(volmu2);
foreach body bb do { set bb.Rk ((3*bb.sphere_target)/(4*Pi))^(1/3) };
rbar := sum(body, Rk)/body_count;
R32  := sum(body, Rk^3)/sum(body, Rk^2);
R0   := (sum(body, Rk^3)/sum(body, 1))^(1/3);
epsilon := abs(R32/R0-1);
rmu2 := sum(body, (Rk - rbar)^2 )/body_count;
rsigma := sqrt(rmu2);

printf "\n  Foam polydispersity with cell volumes scaled by sphere volumes\n";
      printf "\n           p = %8.6f  (R32/R0-1)\n", epsilon;
//        printf " Fmu2/Fbar^2 = %8.6f\n", Fmu2/Fbar^2;
        printf " Rsigma/Rbar = %8.6f\n\n", rsigma/rbar;
printf " sum body.sphere_target = %g\n", sum(body, sphere_target);
printf "        sum body.volume = %g\n", sum(body, volume);

printf "   *** F_stats sphere targets ***\n"
};


set facet tension 2/body_count;
set integral_order_1d 7;
set integral_order_2d 11;

if read_FA==1 then read "face_areas";
if read_EL==1 then read "edge_lengths";

define body attribute sqJ2 real;

calc_sJ2 := { foreach body bb do { 
Sxxb := sum( bb.facet, Sxxq ); Syyb := sum( bb.facet, Syyq ); 
Szzb := sum( bb.facet, Szzq ); Sxyb := sum( bb.facet, Sxyq ); 
Syzb := sum( bb.facet, Syzq ); Szxb := sum( bb.facet, Szxq ); 
sJ2b := sqrt ( ((Sxxb-Syyb)^2+(Syyb-Szzb)^2+(Sxxb-Szzb)^2)/6 
	+Sxyb^2+Syzb^2+Szxb^2 ); 
// printf "%4g%14.8f%14.8f\n", bb.id, sJ2b, sJ2b/(bb.volume)^(2/3); 
set bb.sqJ2 sJ2b }; 
sJ2b_bar := sum(body,sqJ2/volume^(2/3))/sum(body,volume); 
print sJ2b_bar
}

define body attribute sqQ real;
// MODIFY foam.eh TOO!!

calc_sJ2_sQ := { foreach body bb do { 
Sxxb := sum( bb.facet, Sxxq ); Syyb := sum( bb.facet, Syyq ); 
Szzb := sum( bb.facet, Szzq ); Sxyb := sum( bb.facet, Sxyq ); 
Syzb := sum( bb.facet, Syzq ); Szxb := sum( bb.facet, Szxq ); 
sJ2b := sqrt ( ((Sxxb-Syyb)^2+(Syyb-Szzb)^2+(Sxxb-Szzb)^2)/6 
	+Sxyb^2+Syzb^2+Szxb^2 ); 
Qxxb := sum( bb.facet, Qxxq ); Qyyb := sum( bb.facet, Qyyq ); 
Qzzb := sum( bb.facet, Qzzq ); Qxyb := sum( bb.facet, Qxyq ); 
Qyzb := sum( bb.facet, Qyzq ); Qzxb := sum( bb.facet, Qzxq ); 
/*
sQb  := sqrt ( ((Qxxb-Qyyb)^2+(Qyyb-Qzzb)^2+(Qxxb-Qzzb)^2)/6 
	+Qxyb^2+Qyzb^2+Qzxb^2 ); 
*/
sQb  := sqrt ( (Qxxb^2+Qyyb^2+Qzzb^2)/2 +Qxyb^2+Qyzb^2+Qzxb^2 ); 

set bb.sqJ2 sJ2b; 
set bb.sqQ sQb;
};

/*
sJ2b_bar := sum(body,sqJ2/volume^(2/3))/sum(body,volume); 
sQb_bar := sum(body,sqQ/volume^(2/3))/sum(body,volume); 
print sJ2b_bar; 
print sQb_bar; 
*/
}

	// calculate and print out the costs of the foam
measure := {
	abar := total_area/body_count;
	vbar := sum(body,volume)/body_count;
	lbar := sum(edge where valence>2, length)/body_count;
	cost := abar^3/vbar^2;
	lcst := lbar^3/vbar;
	trvs := sum(vertex vv where sum(vv.edge,valence>2)==2, 1);
	zbar := (3*facet_count-2*edge_count-trvs)/body_count + 2;
	recalc }

report := {
	measure;
	printf "cost% #13.10g (% #12.10g); len% #14.10g (% #12.10g); zbar% #13.10g\n",
	cost, 2*cost^(1/3), lcst, lcst^(1/3), zbar }

	// calculate the stress components for a dry soap froth
stresscalc := {
	recalc; sfac := 2/body_count/(sum(body,volume)/body_count)^(2/3);
	Sxx := sfac*total Sxxq; Syy := sfac*total Syyq; Szz := sfac*total Szzq;
	Sxy := sfac*total Sxyq; Syz := sfac*total Syzq; Szx := sfac*total Szxq;
	dP := (Sxx+Syy+Szz)/3 }

	// print the stress components for a dry soap froth
stresses := {
	stresscalc;
        sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
	printf "\n";
	printf "  Sxx-Syy = %16.12f\n", Sxx-Syy;
	printf "  Syy-Szz = %16.12f\n", Syy-Szz;
	printf "  Szz-Sxx = %16.12f\n", Szz-Sxx;
	printf "      Sxy = %16.12f\n", Sxy;
	printf "      Syz = %16.12f\n", Syz;
	printf "      Szx = %16.12f\n", Szx; 
	printf "      sJ2 = %16.12f\n", sJ2_tot }

re := {recalc; stresses; report};

	// This will color all hexagons red (if executed before any refining)
hexes := foreach vertex vv where vv.original<0 and vv.valence==6 do 
	set vv.facet color red;
quads := foreach vertex vv where vv.original<0 and vv.valence==4 do 
	set vv.facet color blue;

	// Color all 14-hedra yellow, etc
yell14 := foreach body bb where valence=6*(14-2) do set bb.facet color yellow;
gree15 := foreach body bb where valence=6*(15-2) do set bb.facet color green;
blue16 := foreach body bb where valence=6*(16-2) do set bb.facet color blue;

	// Show only colored faces
nowhite := { show_expr facet where color != white }

bij :=	{
	b1x := torus_periods[1][1];
	b1y := torus_periods[1][2];
	b1z := torus_periods[1][3];
	b2x := torus_periods[2][1];
	b2y := torus_periods[2][2];
	b2z := torus_periods[2][3];
	b3x := torus_periods[3][1];
	b3y := torus_periods[3][2];
	b3z := torus_periods[3][3] }
bij;

//	"center" each face vertex
center_face_vertex := { 
foreach vertex vv where sum(vv.edge where valence==2,1)==sum(vv.edge,1) do { 
vvx := 0; vvy := 0; vvz := 0; 
foreach vv.edge ee do { 
       if ee.wrap == 0 then      {lx:=   0;ly:=   0;lz:=   0}
  else if ee.wrap == 1 then      {lx:= b1x;ly:= b1y;lz:= b1z}
  else if ee.wrap == 31 then     {lx:=-b1x;ly:=-b1y;lz:=-b1z}
  else if ee.wrap == 64 then     {lx:= b2x;ly:= b2y;lz:= b2z}
  else if ee.wrap == 65 then     {lx:= b1x+b2x;ly:= b1y+b2y;lz:= b1z+b2z}
  else if ee.wrap == 95 then     {lx:=-b1x+b2x;ly:=-b1y+b2y;lz:=-b1z+b2z}
  else if ee.wrap == 1984 then   {lx:=-b2x;ly:=-b2y;lz:=-b2z}
  else if ee.wrap == 1985 then   {lx:= b1x-b2x;ly:= b1y-b2y;lz:= b1z-b2z}
  else if ee.wrap == 2015 then   {lx:=-b1x-b2x;ly:=-b1y-b2y;lz:=-b1z-b2z}
  else if ee.wrap == 4096 then   {lx:= b3x;ly:= b3y;lz:= b3z}
  else if ee.wrap == 4097 then   {lx:= b1x+b3x;ly:= b1y+b3y;lz:= b1z+b3z}
  else if ee.wrap == 4127 then   {lx:=-b1x+b3x;ly:=-b1y+b3y;lz:=-b1z+b3z}
  else if ee.wrap == 4160 then   {lx:= b2x+b3x;ly:= b2y+b3y;lz:= b2z+b3z}
  else if ee.wrap == 4161 then   {lx:= b1x+b2x+b3x;ly:= b1y+b2y+b3y;lz:= b1z+b2z+b3z}
  else if ee.wrap == 4191 then   {lx:=-b1x+b2x+b3x;ly:=-b1y+b2y+b3y;lz:=-b1z+b2z+b3z}
  else if ee.wrap == 6080 then   {lx:=-b2x+b3x;ly:=-b2y+b3y;lz:=-b2z+b3z}
  else if ee.wrap == 6081 then   {lx:= b1x-b2x+b3x;ly:= b1y-b2y+b3y;lz:= b1z-b2z+b3z}
  else if ee.wrap == 6111 then   {lx:=-b1x-b2x+b3x;ly:=-b1y-b2y+b3y;lz:=-b1z-b2z+b3z}
  else if ee.wrap == 126976 then {lx:=-b3x;ly:=-b3y;lz:=-b3z}
  else if ee.wrap == 126977 then {lx:= b1x-b3x;ly:= b1y-b3y;lz:= b1z-b3z}
  else if ee.wrap == 127007 then {lx:=-b1x-b3x;ly:=-b1y-b3y;lz:=-b1z-b3z}
  else if ee.wrap == 127040 then {lx:= b2x-b3x;ly:= b2y-b3y;lz:= b2z-b3z}
  else if ee.wrap == 127041 then {lx:= b1x+b2x-b3x;ly:= b1y+b2y-b3y;lz:= b1z+b2z-b3z}
  else if ee.wrap == 127071 then {lx:=-b1x+b2x-b3x;ly:=-b1y+b2y-b3y;lz:=-b1z+b2z-b3z}
  else if ee.wrap == 128960 then {lx:=-b2x-b3x;ly:=-b2y-b3y;lz:=-b2z-b3z}
  else if ee.wrap == 128961 then {lx:= b1x-b2x-b3x;ly:= b1y-b2y-b3y;lz:= b1z-b2z-b3z}
  else if ee.wrap == 128991 then {lx:=-b1x-b2x-b3x;ly:=-b1y-b2y-b3y;lz:=-b1z-b2z-b3z}; 

vvx := vvx + lx + ee.vertex[2].x; vvy := vvy + ly + ee.vertex[2].y; vvz := vvz + lz + ee.vertex[2].z }; 
vv.x := vvx/sum(vv.edge,1); vv.y := vvy/sum(vv.edge,1); vv.z := vvz/sum(vv.edge,1) } };

/*
//strain := b1y/b1z; // strain := b2y/b2z; // strain := b3y/b3z; 
//b1y0 := b1y; strain := (b1y-b1y0)/b1z;
//b2y0 := b2y; strain := (b2y-b2y0)/b2z;
//b3y0 := b3y; strain := (b3y-b3y0)/b3z;
b1y0 := b1y; strain := (b1y-b1y0)/b1z;
b2y0 := b2y; strain := (b2y-b2y0)/b2z;
b3y0 := b3y; strain := (b3y-b3y0)/b3z;
*/

// strain := b3y/b3z; 

bij_0 := { bij; b1y0 := b1y; b2y0 := b2y; b3y0 := b3y }

//set_strain := { strain := 0 };
//set_strain; 

pbij := { bij; 

//if abs(b1z) > 0.1 then  set_strain := { strain := abs(b1y/b1z + strain_shift)};
//if abs(b2z) > 0.1 then  set_strain := { strain := abs(b2y/b2z + strain_shift)};
//if abs(b3z) > 0.1 then  set_strain := { strain := abs(b3y/b3z + strain_shift)};

if abs(b1z) > 0.1 then  set_strain := { strain := abs((b1y-b1y0)/b1z)};
if abs(b2z) > 0.1 then  set_strain := { strain := abs((b2y-b2y0)/b2z)};
if abs(b3z) > 0.1 then  set_strain := { strain := abs((b3y-b3y0)/b3z)};

printf " b1 = ( %16.12f %16.12f %16.12f )\n", b1x, b1y, b1z;
printf " b2 = ( %16.12f %16.12f %16.12f )\n", b2x, b2y, b2z;
printf " b3 = ( %16.12f %16.12f %16.12f )\n", b3x, b3y, b3z;
//strain := b1y/b1z;
//strain := b2y/b2z;
//strain := b3y/b3z;
//strain := (b1y-b1y0)/b1z;
//strain := (b2y-b2y0)/b2z;
//strain := (b3y-b3y0)/b3z;
//set_strain := { strain := 0 };
set_strain; 
printf " strain = %g \n", strain;
};

minE := { MinEid := 0; minL := 100; 
foreach body bb where bbf==4 do set bb.facet color black; 
  Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
  foreach edge ee where ee.valence == 3 and min(ee.facet ff, ff.color==11) do { 
    if (ee.length < minL) then { minL := ee.length; MinEid := ee.id} }; 
  if sum(edge where valence>=3 and length < minL,1) > 0 then printf "\n"; 
  foreach edge ee where ee.valence == 3 do { 
    if (ee.length < minL) then { 
	printf "  the short edge %g is on a tetrahedron\n", ee.id; } }; 
  if sum(edge where valence>=3 and length < minL,1) > 0 then printf "\n"; 
fec }; 

minE_spheres := { MinEid := 0; minL := 100; 
  Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
  foreach edge ee where ee.valence == 3 do { 
    if (ee.length < minL) then { minL := ee.length; MinEid := ee.id} } }; 

Gbar := 0.82;

	// xx: relax the lattice
my_xmin := {
	stresscalc;
	TS:= Sxx-Syy/2-Szz/2;
	mxx:= 1/(1+TS/Gbar/3);
	myy:= sqrt(1+TS/Gbar/3);
	mzz:= sqrt(1+TS/Gbar/3);
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// yy: relax the lattice
my_ymin := {
	stresscalc;
	TS:= Syy-Sxx/2-Szz/2;
	mxx:= sqrt(1+TS/Gbar/3);
	myy:= 1/(1+TS/Gbar/3);
	mzz:= sqrt(1+TS/Gbar/3);
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// zz: relax the lattice
my_zmin := {
	stresscalc;
	TS:=Szz-Sxx/2-Syy/2;
	mxx:= sqrt(1+TS/Gbar/3);
	myy:= sqrt(1+TS/Gbar/3);
	mzz:= 1/(1+TS/Gbar/3);
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// xx, yy: relax the lattice
my_xymin := {
	stresscalc;
	BS:= Sxx-Syy;
	mxx:= 1/(1+BS/Gbar/4);
	myy:= 1/mxx;
	mzz:= 1;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// yy, zz: relax the lattice
my_yzmin := {
	stresscalc;
	BS:= Syy-Szz;
	mxx:= 1;
	myy:= 1/(1+BS/Gbar/4);
	mzz:= 1/myy;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// xx, zz: relax the lattice
my_zxmin := {
	stresscalc;
	BS:= Szz-Sxx;
	mxx:= (1+BS/Gbar/4);
	myy:= 1;
	mzz:= 1/mxx;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// xy: relax the lattice
my_shxymin := {
	stresscalc; mxx:=1; myy:=1; mzz:=1;
	mxy:= -Sxy/Gbar;
	myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// yz: relax the lattice
my_shyzmin := {
	stresscalc; mxx:=1; myy:=1; mzz:=1;
	myz:= -Syz/Gbar;
	mxy:=0; myx:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// zx: relax the lattice
my_shzxmin := {
	stresscalc; mxx:=1; myy:=1; mzz:=1;
	mzx:= -Szx/Gbar;
	mxy:=0; myx:=0; mzy:=0; mxz:=0; mzx:=0; applymat }

	// xy, yz, zx: relax the lattice
my_shmin := {
	stresscalc; mxx:=1; myy:=1; mzz:=1;
	mxy := -Sxy/Gbar;
	myx:=0; myz:=0; mzy:=0; mxz:=0; mzx:=0; applymat;
	myz := -Syz/Gbar;
	mxy:=0; myx:=0; mzy:=0; mxz:=0; mzx:=0; applymat;
	mzx := -Szx/Gbar;
	mxy:=0; myx:=0; myz:=0; mzy:=0; mxz:=0; applymat }

relaxed := {
	p1x:=tp1x; p1y:=tp1y; p1z:=tp1z;
	p2x:=tp2x; p2y:=tp2y; p2z:=tp2z;
	p3x:=tp3x; p3y:=tp3y; p3z:=tp3z;
	set vertex tx x*mxx+y*mxy+z*mxz;
	set vertex ty x*myx+y*myy+z*myz;
	set vertex tz x*mzx+y*mzy+z*mzz;
	set vertex x tx; set vertex y ty; set vertex z tz;
	recalc }

print_stuff_1 := { G_avg := 0; G_f := 0;
wi := {printf "  " >> "data_shear"; 
printf datafilename >> "data_shear"; 
printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear"; 
pbij; 
minE; 
printf "  strain tot_energy       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear"; 
fc0 := facet_count}; 
wi; 
wp := {stresscalc; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear" }; 

wp_G := { sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear"; 
printf "%10.6f\n", G_avg >> "data_shear" }; 

wp_G_spheres := { sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear_spheres"; 
printf "%10.6f\n", G_avg >> "data_shear_spheres" }; 

wp_summary := {stresscalc; minE; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear_summary" }; 

wp_spheres := {stresses; minE_spheres; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear_spheres" }; 


wd := {stresses; minE; wp}; 
}; 

we := {e >> "data_shear"} 
wv := {v >> "data_shear"} 
wr := {report >> "data_shear"} 

pp := { print torus_periods[1][1]; print torus_periods[1][2]; print torus_periods[1][3]; 
        print torus_periods[2][1]; print torus_periods[2][2]; print torus_periods[2][3]; 
        print torus_periods[3][1]; print torus_periods[3][2]; print torus_periods[3][3] };

//nb := { pbij; bij; pbij };

hi := history
wes := {e >> "stats.dat"} 
wvs := {v >> "stats.dat"} 
wrs := {report >> "stats.dat"} 
preport := {report >> "stats.dat"} 

bij; 

fc := {set facet color 11}
fc;

r111 := { phi := -pi/2; theta := -atan(sqrt(2)); recalc; rotmat }
r110 := { theta := -pi/4; psi := -pi/2; recalc; rotmat }

define body attribute initial_volume real; 
// v_steps := 20; 
v_steps := 5; 

relax_volume := { printf "\n      v_steps = %g\n\n", v_steps; 
set body initial_volume volume; 
ii := 1; 
while ii <= v_steps do { 
set body target initial_volume + (old_target-initial_volume) * ii/v_steps; 
unset_bb_target := 1; 
foreach body bb do { if unset_bb_target == 1 then { unset bb target; unset_bb_target := 0 }; }; 
g; ii := ii + 1 }; 
// histogram(body where id > 1, (volume - old_target)/old_target ) 
};

if read_CN == 1 then  read "cell_neighbors";

if read_SF==0 then read "relax_foam"
if read_SF==1 then read "relax_foam"

she := {histogram(edge where valence == 3, length)}

he := {	short_edge := ELtol*sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
	printf "   %g  -- avg edge length\n", 
	sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
	printf "   %g  -- edge tolerance\n", short_edge; 
	histogram(edge where valence>=3, length); 
foreach body bb where bbf==4 do set bb.facet color black; 
printf " %g short edges\n",sum(edge ee where ee.valence>=3 and ee.length < short_edge and min(ee.facet ff, ff.color==11),1); 
fec }

hel := { short_edge := ELtol*sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
	printf "   %g  -- avg edge length\n", 
	sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
	printf "   %g  -- edge tolerance\n", short_edge; 
	histogram(edge where valence>=3, length); 
foreach body bb where bbf==4 do set bb.facet color black; 
printf " %g short edges\n",sum(edge ee where ee.valence>=3 and ee.length and min(ee.facet ff, ff.color==11) < short_edge,1);
list edges ee where ee.valence>=3 and ee.length < short_edge and min(ee.facet ff, ff.color==11); 
fec }

//if read_SF==1 then read "relax_shear_foam"

if read_EA==1  then read "evolver_to_ABAQUS"
if read_EAC==1 then read "evolver_to_ABAQUS_cube"

//read "my_dump" 			// if not called from relax_foam
//read "evolver_beams"
//read "evolver_to_ABAQUS"
//read "my_sort"
//read "polyvol.dat"
//read "polyvol"

//read "iman_targets"

//read "closed_kelvin_abaqus"		// Andy's routines
//read "evolver_to_ABAQUS_closed"	// Andy's routines
//read "foam_metric.c"			// Andy's routines
//read "Voronoi_bone.c"			// Andy's routines
//read "my_cell_image"			// Andy's routines

//unset body[1] target;
unset_bb_target := 1; 
foreach body bb do { if unset_bb_target == 1 then { unset bb target; unset_bb_target := 0 }; }; 

set_tx_ty_tz := { set vertex tx 0; set vertex ty 0; set vertex tz 0 };
set_tx_ty_tz;

// print_stuff_1

/*
set_bidisperse := { vol_ratio := 3.0; 
set body target 4/(3 + vol_ratio); 
set body[5] target vol_ratio*4/(3 + vol_ratio); 
unset body[1] target };
*/

color_unwrapped_bodies := { 
set facet color -1; 
foreach facet ff where (ff.edge[1].wrap==0 and ff.edge[2].wrap==0 
and ff.edge[3].wrap==0) do { set ff color red }; 
foreach body bb where sum(bb.facet where color==red,1)==sum(bb.facet,1) do 
{ set bb facet color green }; 
foreach facet ff where color==red do { set ff color -1 } }

rq := { r; m 0; g; optimize; g }

Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 

pminE := { minE; 
    if minL < Ebar/100 then { 
    printf " Ebar = %g  MinEid = %g  minL = %g\n", Ebar, MinEid, minL; 
    printf " Ebar = %g  MinEid = %g  minL = %g\n", Ebar, MinEid, minL >> "data_shear"; 
    list edges where ( valence == 3 and length < Ebar/10 and length < Ebar/100); 
    list edges where ( valence == 3 and length < Ebar/10 and length < Ebar/100) >> "data_shear" } }; 

poly_F_stats := { F_stats; 
printf " %10.6f%10.6f%10.6f%10.6f  %s\n",rsigma/rbar,rbar,R21,R32,datafilename >> "R_stats.dat" };

R_stats := { F_stats; 
printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n",rsigma/rbar,rbar/R0,R32/R0,rbar*R32/R0^2,epsilon,rbar,R32,R21,datafilename; 
printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n",rsigma/rbar,rbar/R0,R32/R0,rbar*R32/R0^2,epsilon,rbar,R32,R21,datafilename >> "R_stats.dat" };

//mu := {U; g20; U; g10; stresses}
// set edge quantity dihooke where valence==2
// dihooke.modulus := 100

nfaces := 10

polyfaces := {sumfaces := 0; nbb:= 0;
foreach body bb where ((sum(bb.facet,1)+12)/6 + 
sum( bb.facet ff where ff.edge[1].valence>=3 and 
ff.edge[2].valence>=3 and ff.edge[3].valence>=3,1)/3)==nfaces do { 
nbb := nbb + 1; 
sumfaces := sumfaces + sum(bb.facet,area)}; 
if nbb != 0 then {printf "  %g   %g   %g\n",nfaces,nbb,sumfaces/nbb} }

doit := {while nfaces <= 18 do { polyfaces; nfaces := nfaces + 1}; nfaces := 10}

// stats; count_the_cell_types		if ccells==1

if read_VA == 1 then { define edge attribute angle real; read "vertex_angles"}

gg := {U; g20; U; g10};
gg := {U; g30; U };
gs := {gg; minE; hel; stresses};
gsp := { gs; wp};

delft1 := { 
M 2; 
print_stuff_1; 
gsp 10 };

delft2 := { 
shrmat; 
M 2; 
print_stuff_1; 
gsp 15; 
linear; 
set_face_vertex; 
shrmat; 
M 2; 
print_stuff_1; 
gsp 15; 
};

delft3 := { 
shrmat; 
M 2; 
print_stuff_1; 
gsp 10; 
linear; 
set_face_vertex; 
shrmat; 
M 2; 
print_stuff_1; 
gsp 10; 
M 1; 
};

delft4 := { 
shrmat; 
M 2; 
print_stuff_1; 
// gsp 10; 
gsp 5; 
M 1; 
set_face_vertex; 
};

G_gam := 0.05;
//G_gam := 0.10;

delft := { 

shrmat; relax_volume; M 2; print_stuff_1; 

// gsp 5; 

N_avg := 1 ; stress_avg := 10; count_avg := 1; 

while ( ( N_avg <= count_avg ) and ( scale > 0.001 ) ) do { gs; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { stress_avg := stress_avg + sJ2_tot; E_RR := total_energy }; 
if xyshr > 0.001 then { stress_avg := stress_avg + Sxy }; 
if yzshr > 0.001 then { stress_avg := stress_avg + Syz }; 
if zxshr > 0.001 then { stress_avg := stress_avg + Szx }; 

G_avg := stress_avg / ( N_avg * G_gam ) ; 

wp_G; 

N_avg := N_avg + 1 }; 

printf "%10.6f\n", G_avg >> "data_G"; 

// M 2; set_face_vertex; 
};

gs_spheres := { gs; wp_spheres }; 

delft_spheres := { 

shrmat; relax_volume; M 2; print_stuff_1; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_spheres"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_spheres"; 

gs_spheres 5; 

N_avg := 1 ; stress_avg := 0; count_avg := 10; 

while ( ( N_avg <= count_avg ) and ( scale > 0.001 ) ) do { gs; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { stress_avg := stress_avg + sJ2_tot; E_RR := 2 * sum(facet,area) / sum(body,volume) }; 
if xyshr > 0.001 then { stress_avg := stress_avg + Sxy }; 
if yzshr > 0.001 then { stress_avg := stress_avg + Syz }; 
if zxshr > 0.001 then { stress_avg := stress_avg + Szx }; 

G_avg := stress_avg / ( N_avg * G_gam ) ; 

wp_G_spheres; 

N_avg := N_avg + 1 }; 

printf "%10.6f\n", G_avg >> "data_G_spheres"; 

M 1; set_face_vertex; 
};

calc_G0 := { 
reset_shear := { 
xyshr := - xyshr; 
yzshr := - yzshr; 
zxshr := - zxshr; 
shrmat; 
xyshr := 0; 
yzshr := 0; 
zxshr := 0 }; 

xyshr := 0.05; 
	delft; 
	reset_shear; 
yzshr := 0.05; 
	delft; 
	reset_shear; 
zxshr := 0.05; 
	delft; 
	reset_shear; 
};

/*	REMEMBER TO SET G_gam	*/	

calc_G := { 

printf datafilename >> "data_G"; 

reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 

delft; 

G_bar := 0; 

xyshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 

phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4;  rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 

G_bar := G_bar / 9; 

printf "\n%10.6f\n", G_bar >> "data_G"; 

F_stats; 

printf "\n%9.6f%10.6f%12.6f%13.7f%12.7f%12.6f%12.6f    %s\n", 
epsilon, rsigma/rbar, Fmu2/Fbar^2, sqrt(Fmu2/Fbar^2), E_RR, G_bar, G_bar/E_RR, datafilename >> "data_G";

pbij };


calc_G_ICR := { 

printf datafilename >> "data_G"; 

reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 

delft; 

G_bar := 0; 

xyshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 

xyshr := -G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
yzshr := -G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := -G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 

phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4;  rotmat; 
yzshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 

G_bar := G_bar / 12; 

printf "\n%10.6f\n", G_bar >> "data_G"; 

F_stats; 

printf "\n%9.6f%10.6f%12.6f%13.7f%12.7f%12.6f%12.6f    %s\n", 
epsilon, rsigma/rbar, Fmu2/Fbar^2, sqrt(Fmu2/Fbar^2), E_RR, G_bar, G_bar/E_RR, datafilename >> "data_G";

pbij };


calc_G_spheres := { 

printf datafilename >> "data_G_spheres"; 

reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 

delft_spheres; 

G_bar := 0; 

xyshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
yzshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 

phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
yzshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
yzshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4;  rotmat; 
yzshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
zxshr := G_gam; delft_spheres; reset_shear; G_bar := G_bar + G_avg; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 

G_bar := G_bar / 9; 

printf "\n%10.6f\n", G_bar >> "data_G_spheres"; 

F_stats; 

printf "\n%9.6f%10.6f%12.6f%13.7f%12.7f%12.6f%12.6f    %s\n", 
epsilon, rsigma/rbar, Fmu2/Fbar^2, sqrt(Fmu2/Fbar^2), E_RR, G_bar, G_bar/E_RR, datafilename >> "data_G_spheres";

pbij };


calc_G_01 := { 
reset_shear := { 
xyshr := - xyshr; 
yzshr := - yzshr; 
zxshr := - zxshr; 
shrmat; 
xyshr := 0; 
yzshr := 0; 
zxshr := 0 }; 
delft; 
xyshr := 0.01; 
	delft; 
	reset_shear; 
yzshr := 0.01; 
	delft; 
	reset_shear; 
zxshr := 0.01; 
	delft; 
	reset_shear; 
phi := Pi/4; theta := 0; psi := 0; 
rotmat; 
yzshr := 0.01; 
	delft; 
	reset_shear; 
zxshr := 0.01; 
	delft; 
	reset_shear; 
phi := - Pi/4; theta := 0; psi := 0; 
rotmat; 
phi := 0; theta := Pi/2; psi := Pi/4; 
yzshr := 0.01; 
	delft; 
	reset_shear; 
zxshr := 0.01; 
	delft; 
	reset_shear; 
phi := - Pi/4; theta := - Pi/2; psi := 0; 
rotmat; 
phi := Pi/2; theta := Pi/2; psi := Pi/4; 
yzshr := 0.01; 
	delft; 
	reset_shear; 
zxshr := 0.01; 
	delft; 
	reset_shear; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2;
rotmat; 
pbij;
};

// if read_RL == 1 then read "relax_lattice"; 

gu := { U; g30; U }

count_Matzke_cells := { stats; count_cell_types }

stretch := { strain := 0; 

theta := Pi/4; rotmat; 

print_stuff := { 
wi := {
printf "  strain tot_energy       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear" };
wi; 
wp := {stresscalc; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f  ", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear" }; 
wd := {stresses;  minE; wp} };
print_stuff; 
gd := { U; g30; U; wd }; 

eps := 0.01; 
zstr := exp(eps); 
xstr := exp(-eps/2); 
ystr := xstr; 
max_strain := 0.250; 
r; 
go_flow := { while strain <= max_strain do { strmat; 
strain := strain + eps; 
M 2; 
gu 5; 
wd; M 1; set_face_vertex } }; 
go_flow }

foam_stats := { F_stats; 

pfs := { report; printf "%9.6f%9.6f%9.6f%8.4f%11.6f%9.6f%9.6f%9.6f%9.6f", 
2*cost^(1/3),lcst^(1/3),sum(edges where valence>=3,length)/sum(edges where valence>=3,1),
fbar,Fmu2,Fmu2/fbar^2,rbar,rsigma,rsigma/rbar >> "poly_metrics.dat";
printf "%9.6f%9.6f  %s\n", sJ2_tot, minL, datafilename >> "poly_metrics.dat" };

//gfs := {M 2; U; g50; U; minE; stresses; pfs };
gfs := {minE; stresses; pfs };
gfs
};

foam_stats_M1 := { F_stats; 

pfs := { report; printf "%9.6f%9.6f%9.6f%8.4f%11.6f%9.6f%9.6f%9.6f%9.6f", 
2*cost^(1/3),lcst^(1/3),sum(edges where valence>=3,length)/sum(edges where valence>=3,1),
fbar,Fmu2,Fmu2/fbar^2,rbar,rsigma,rsigma/rbar >> "poly_metrics.dat";
printf "%9.6f%9.6f  %s\n", sJ2_tot, minL, datafilename >> "poly_metrics.dat" };

gfs := {minE; stresses; pfs };
gfs
};

psstmp := 1             // set psstmp := 1 if you want to label the columns in stavros_metrics.dat

stavros_stats := { 

if psstmp==1 then { printf "        E     L_tot     L_avg        F       C_R     L_min     V_max         filename\n" >> "stavros_metrics.dat"; psstmp := 0 };

F_stats;

max_vol	:= 1;
foreach body bb do { if	bb.volume > max_vol then max_vol := bb.volume};

pss := { report; printf "%9.6f %9.6f %9.6f %8.4f %9.6f",
2*cost^(1/3),lcst^(1/3),sum(edges where valence>=3,length)/sum(edges where valence>=3,1),
fbar, rsigma/rbar >> "stavros_metrics.dat";
printf " %9.6f %9.6f  %s\n", minL, max_vol, datafilename >> "stavros_metrics.dat" };

gfs := {minE; stresses; pss };
gfs
};

//count_Matzke_cells := { stats; count_cell_types }
//sally := { count_Matzke_cells; aw; poly_matzke }
//sally; q; q;

//coarsen := { stats; count_cell_types; g50; calc_D; facet_facet_P; facet_facet_PR; rank_cell_types }

/*
coarsen := { stats; count_cell_types; calc_sJ2; cell_D; rank_cell_dVdt }
coarsen := { stats; count_cell_types; M 2; gu 3; calc_sJ2; cell_D; rank_cell_dVdt }
relax_wp := { gu 3; calc_sJ2; cell_D; rank_cell_dVdt }

shear_wp := { coarsen;
gamma := 0;
xyshr := 0.05;
while gamma <= 0.75 do { shrmat; relax_wp; gamma := gamma + xyshr } }
*/

//	M_1 = M beta/3 + 1/2
//	M_2 = M beta/3
//	M_3 = M 9/4 1/3 + 1/2 = M 5/4
//	M_4 = M 3/4

V_beta := 9/4;
Denis := { 
exponent1 := V_beta/3 + 1/2;
exponent2 := V_beta/3;
M_1 := sum(body,bbf^exponent1)/sum(body,bbf^exponent2);
M_2 := sum(body,bbf^(5/4))/sum(body,bbf^(3/4));
printf "%8.4f%9.4f%9.4f  %s\n", V_beta, M_1^2, M_2^2, datafilename;
printf "%8.4f%9.4f%9.4f  %s\n", V_beta, M_1^2, M_2^2, datafilename >> "Denis.dat";
}

// coarsen := { stats; count_cell_types; foam_stats }
// sally := { foam_stats }
// sally := { count_Matzke_cells; poly_matzke }
// poly_matzke
// coarsen := { stats; count_cell_types; M 2; U; g50; U; calc_D }
// F_stats
// Denis
//sally  := { 
//phi := 0; theta := 0; psi := 0; rotmat; bij_0; 
//phi := Pi/2; theta := 0; psi := 0; rotmat; bij_0; 
//phi := 0; theta := Pi/2; psi := 0; rotmat; bij_0; 
//phi := Pi/2; theta := Pi/2; psi := -Pi/2; rotmat; bij_0; 
//phi := Pi; theta := Pi/2; psi := -Pi/2; rotmat; bij_0; 
//phi := -Pi; theta := 0; psi := 0; rotmat; bij_0; 
//phi := Pi/2; theta := Pi/2; psi := Pi/2; rotmat; bij_0; 
//phi := 0; theta := Pi/2; psi := Pi; rotmat; bij_0; 
//stats2 >> "stats.dat"; while ( minL > do_T1 ) do go_baby_NEWTON }
//sally

vs := { phi := sum(body bb, (4*PI*(bb.radius)^3/3))/body_count; 
printf "#  phi = %8.6f\n", phi; 
printf "#  phi = %8.6f\n", phi >> "voronoi_sphere.dat"; 
printf "#  %s\n", datafilename >> "voronoi_sphere.dat"; 
printf "#  body      Vb    radius        Vs       Vb/Vs       Vs/Vb\n" >> "voronoi_sphere.dat"; 
foreach body bb do { 
printf " %4g%10.6f%10.6f%10.6f  %10.6f  %10.6f\n", bb.id, bb.volume, bb.radius, 
4*PI*(bb.radius)^3/3, bb.volume/(4*PI*(bb.radius)^3/3), 
(4*PI*(bb.radius)^3/3)/bb.volume >> "voronoi_sphere.dat" } }

// rrl := read "relax_lattice"

rank_Sij := { 
if abs(Sxx-Syy) > abs(Syy-Szz) then 
{ BAmax := abs(Sxx-Syy); BAij := 1 } else 
{ BAmax := abs(Syy-Szz); BAij := 2 }; 
if abs(Szz-Sxx) > BAmax then 
{ BAmax := abs(Szz-Sxx); BAij := 3 }; 
if abs(Sxy) > abs(Syz) then SHmax := abs(Sxy) else SHmax := abs(Syz); 
if abs(Szx) > SHmax then SHmax := abs(Szx) }

//	modified 7/11/2003
relax_bij := { rank_Sij; 
if BAmax > 0.00002 or SHmax > 0.00002 then { 
if BAmax^2/6 > SHmax^2 then { 
	if BAij == 1 then 
{ if abs(Syy-Szz)/abs(Sxx-Syy) > 0.8 then 
{ printf " Doing my_ymin and my_shmin\n"; my_ymin; my_shmin } else 
{ if abs(Szz-Sxx)/abs(Sxx-Syy) > 0.8 then 
{ printf " Doing my_xmin and my_shmin\n"; my_xmin; my_shmin } else 
{ printf " Doing my_xymin and my_shmin\n"; my_xymin; my_shmin } } }; 
	if BAij == 2 then 
{ if abs(Sxx-Syy)/abs(Syy-Szz) > 0.8 then 
{ printf " Doing my_ymin and my_shmin\n"; my_ymin; my_shmin } else 
{ if abs(Szz-Sxx)/abs(Syy-Szz) > 0.8 then 
{ printf " Doing my_zmin and my_shmin\n"; my_zmin; my_shmin } else 
{ printf " Doing my_yzmin and my_shmin\n"; my_yzmin; my_shmin } } }; 
	if BAij == 3 then 
{ if abs(Sxx-Syy)/abs(Szz-Sxx) > 0.8 then 
{ printf " Doing my_xmin and my_shmin\n"; my_xmin; my_shmin } else 
{ if abs(Syy-Szz)/abs(Szz-Sxx) > 0.8 then 
{ printf " Doing my_zmin and my_shmin\n"; my_zmin; my_shmin } else 
{ printf " Doing my_zxmin and my_shmin\n"; my_zxmin; my_shmin } } } }
	else { printf " Doing my_shmin\n"; my_shmin } } }

go_bears_bij := { sum_short_edges := 1; print_stuff_1; relax_volume; M 2; gsp 3; 
while ( sJ2_tot > 0.00005 and minL > 0.02 ) do { 
Gbar := 0.155 * total_energy; printf "\n      Gbar = %g\n\n", Gbar; 
relax_bij; gsp 3 }; stresses; 
foreach body bb where bbf==4 do set bb.facet color black; 
sum_short_edges := sum(edges ee where ee.valence>=3 and ee.length < short_edge and min(ee.facet ff, ff.color==11), 1); 
fec }

go_bears_bij_KBR := { sum_short_edges := 1; print_stuff_1; wp; 
while ( sJ2_tot > 0.00005 and minL > 0.02 ) do { 
Gbar := 0.155 * total_energy; printf "\n      Gbar = %g\n\n", Gbar; 
relax_bij; gsp 3 }; stresses; 
foreach body bb where bbf==4 do set bb.facet color black; 
sum_short_edges := sum(edges ee where ee.valence>=3 and ee.length < short_edge and min(ee.facet ff, ff.color==11), 1); 
fec }

go_bears_bij_KBR := { sum_short_edges := 1; print_stuff_1; wp; 
while ( sJ2_tot > 0.00001 and minL > 0.02 ) do { 
Gbar := 0.155 * total_energy; printf "\n      Gbar = %g\n\n", Gbar; 
relax_bij; gsp 3 }; stresses; 
foreach body bb where bbf==4 do set bb.facet color black; 
sum_short_edges := sum(edges ee where ee.valence>=3 and ee.length < short_edge and min(ee.facet ff, ff.color==11), 1); 
fec }

her := { // define vertex attribute edge_len real; 
	temp1 := sum(edge where valence>=3, length); 
	temp2 := sum(edge where valence>=3, 1) - sum(vertex vv where sum(vv.edge where valence>=3,1)==2,1); 
printf "   %g  -- avg edge length\n", temp1/temp2; 
foreach vertex vv where sum(vv.edge where valence>=3,1)==2 do 
	{set vv.edge_len sum(vv.edge ee where ee.valence>=3,length)}; 
short_edge :=  ELtol*temp1/temp2; 
printf "   %g  -- edge tolerance\n", short_edge; 
histogram(vertex vv where sum(vv.edge where valence>=3,1)==2,edge_len );
printf " %g short edges\n",sum(vertex vv where 
sum(vv.edge where valence>=3,1)==2 and vv.edge_len < short_edge,1) };

herl := { // define vertex attribute edge_len real; 
	temp1 := sum(edge where valence>=3, length); 
	temp2 := sum(edge where valence>=3, 1) - sum(vertex vv where sum(vv.edge where valence>=3,1)==2,1); 
printf "   %g  -- avg edge length\n", temp1/temp2; 
foreach vertex vv where sum(vv.edge where valence>=3,1)==2 do 
	{set vv.edge_len sum(vv.edge ee where ee.valence>=3,length)}; 
short_edge :=  ELtol*temp1/temp2; 
printf "   %g  -- edge tolerance\n", short_edge; 
histogram(vertex vv where sum(vv.edge where valence>=3,1)==2,edge_len );
printf " %g short edges\n",sum(vertex vv where 
sum(vv.edge where valence>=3,1)==2 and vv.edge_len < short_edge,1);
list vertex vv where sum(vv.edge where valence>=3,1)==2 and vv.edge_len < short_edge };

minL_r1 := { minL := 100; her; 
foreach vertex vv where sum(vv.edge where valence>=3,1)==2 do { 
    if (vv.edge_len < minL) then minL := vv.edge_len } }

r1_stats := { F_stats; 
r0p := { stresses; minE; hel; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n", 
	R32/((3/(4*Pi))^(1/3))-1,total_energy,sum(edge where valence>2, length)/body_count,
	minL,sJ2_tot,R32,datafilename >> "R_stats.dat" };
r1p := { stresses; minL_r1; herl; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n",
	R32/((3/(4*Pi))^(1/3))-1,total_energy,sum(edge where valence>2, length)/body_count,
	minL,sJ2_tot,R32,datafilename >> "R_stats.dat" };
relax_volume; M 2; {gu; r0p} 6; r; {gu; r1p} 3 }

coarse_r1_stats := { F_stats; 
r0p := { stresses; minE; hel; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%6g  %s\n", 
	epsilon,total_energy,sum(edge where valence>2, length)/body_count,
	2*sum(facet,area)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(1/3), 
	sum(edges where valence>=3,length)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(2/3), 
	minL,sJ2_tot,sum(body,1),datafilename >> "coarse_Lf_Sf.dat" };
r1p := { stresses; minL_r1; herl; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%6g  %s\n",
	epsilon,total_energy,sum(edge where valence>2, length)/body_count,
	2*sum(facet,area)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(1/3), 
	sum(edges where valence>=3,length)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(2/3), 
	minL,sJ2_tot,sum(body,1),datafilename >> "coarse_Lf_Sf.dat" };
M 2; relax_volume; {gu; r0p} 6; r; {gu; r1p} 3 }

if rr1==1 then { read "r1_relax_foam"; printf "      go_bears\n" }

Voronoi_stats := { F_stats; 
r0p := { stresses; minE; hel; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n", 
R32/((3/(4*Pi))^(1/3))-1,total_energy,sum(edge where valence>2, length)/body_count,
minL,sJ2_tot,R32,datafilename >> "R_stats.dat" };
r1p := { stresses; minL_r1; herl; printf " %10.6f%10.6f%10.6f%10.6f%10.6f%10.6f  %s\n",
R32/((3/(4*Pi))^(1/3))-1,total_energy,sum(edge where valence>2, length)/body_count,
minL,sJ2_tot,R32,datafilename >> "R_stats.dat" } }

if rr1==1 then { read "r1_relax_foam"; printf "      go_bears\n" }

x_large := 1.0;

do_bidisperse := { ratio := 16.0; histogram(body,volume); 
N_big := sum(body where volume > x_large,1); 
set_bidisperse := { 
V_big :=   body_count*ratio / ( N_big*(ratio-1) + body_count ); 
V_small :=       body_count / ( N_big*(ratio-1) + body_count ); 
foreach body bb where bb.volume > x_large do { set bb.target V_big }; 
foreach body bb where bb.volume < x_large do { set bb.target V_small}; 
unset body[1] target; 
printf " ratio = %g  %g  x_large := %g\n", ratio, V_big/V_small, x_large };
psv := { print ( (sum(body where volume>x_large,volume)/sum(body where volume>x_large,1))/
	(sum(body where volume<x_large,volume)/sum(body where volume<x_large,1))) };
temp := 0; 
ii := 2; while ii <= body_count do { temp := temp + body[ii].target; ii := ii + 1 }; 
set body[1].target sum(body,volume) - temp; 
pst := { print ( (sum(body where volume>x_large,target)/sum(body where volume>x_large,1))/
	(sum(body where volume<x_large,target)/sum(body where volume<x_large,1))) };
unset body[1] target; 
printf "   N_big = %g  ratio = %g\n", N_big, ratio;
psv; pst }

find := {fec; hel; 

foreach body bb where bbf==4 do set bb.facet color black; 
foreach facet ff where color==black do set ff.edge nu_id 77; 
foreach edge ee where ee.valence>=3 and ee.length < short_edge and nu_id == 77 do { 
	printf "   Won't eliminate edge %g or its facets\n", ee.id }; 

foreach edge ee where ee.valence>=3 and ee.length < short_edge and nu_id != 77 do { 
	set ee.facet color green; set ee.color green}; 

foreach edge ee where nu_id == 77 do { set ee.facet color black }; 

list facet where color==green; 

printf "\n      THESE ARE SHRINKING TRIANGLES\n"; 
foreach facet ff where ff.color==green and face_type==3 do set ff.color blue; 
	if sum(facets where color==blue,1) > 0 then { 
	list facets where color==blue };

printf "\n      THESE ARE SHRINKING QUADS\n"; 
foreach vertex vv where max(vv.facet ff, ff.color==green) and sum(vv.facet,1)==4 and 
min(vv.facet ff, ff.face_type==4) and sum(vv.facet ff where ff.color==green,1)>=2 
and sum(vv.facet ff where ff.color==black,1)==0 do { 
	list vv.facet; 
	set vv.facet color red };

printf "\n      THESE FACETS ARE POTENTIAL PROBLEMS\n"; 
foreach edge ee where ee.valence>=3 and sum(ee.facets where color==blue or color==red,1) >= 2 do 
list ee.facet >> "problems.dat"; 
foreach vertex vv where sum(vv.edge where valence >= 3,1)==4 and sum(vv.facets where color==blue or color==red,1) >= 3 do 
list vv.facet where color != 11 >> "problems.dat"; 

set edge nu_id 0; 
};

ml := { gu; stresses; hel}; mrl := { gu; stresses; herl}

//********************************************************************************
//********************************************************************************

pop_triangles := { printf "\n      START POPPING TRIANGLES\n"; 

foreach facet ff where ff.color==blue and face_type==3 and min(ff.edges ee, ee.valence>=3) 
and max(ff.edges ee, ee.length <= short_edge) do { 

//	color every facet that touches the shrinking facet yellow 
//	so that we don't tamper with it during this cascade
	foreach ff.edge ee do   { set ee.facet color yellow}; 
	foreach ff.vertex vv do { set vv.facet color yellow}; 

set ff.edge color black; 
pop_tri_to_edge facet[ff.id] }; printf "\n      FINISHED POPPING TRIANGLES\n\n" };

//********************************************************************************
//********************************************************************************

flip_quads := { printf "\n      START FLIPPING QUADS\n"; 

//	Make sure we are not flipping a quad that has been altered during this cascade

foreach vertex vv where max(vv.facet ff, ff.color==green) and sum(vv.facet,1)==4 
and min(vv.facet ff, ff.face_type==4) and max(vv.facet ff, ff.color==yellow) do { 

printf "\n\n      WE WON'T BE FLIPPING THIS QUAD\n"; 
list vv.facet; 
set vv.facet color yellow };

//foreach vertex vv where max(vv.facet ff, ff.color==green) and sum(vv.facet,1)==4 and min(vv.facet ff, ff.face_type==4) do { 
//set vv.facet color red; 
//foreach facet ff where color==red do set ff.edge color black; 

pop_quad_to_quad facet where color==red; 

printf "\n\n"; list facets where color != 11; 
printf "\n\n"; list edges where color != black; 
printf "\n      FINISHED FLIPPING QUADS\n\n" };

//********************************************************************************
//********************************************************************************

pop_edges := { printf "\n      START POPPING EDGES\n"; 
foreach edge ee where ee.color==green and min(ee.facet ff, ff.color==green) do { 
set ee.color black; 
set ee.facet color yellow; 
pop_edge_to_tri edge[ee.id] }; printf "\n      FINISHED POPPING EDGES\n\n" };

//********************************************************************************
//********************************************************************************

gogo := { 
stresses; 
stats_dat; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; sft; fc; ce; cf; sod; plateau; 
set_face_type; 
my_compare; 
mg_cycle; so; find
}

printf "\n\n"; list facets where color != 11; 
printf "\n\n"; list edges where color != black; 

relax_foam_M2 := { 
stats_dat; 
if cell_vol != 2 then relax_volume; 
M 2; ml 6; so; find; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
if cell_vol != 2 then relax_volume; 
M 2; ml 6; so; find } }

relax_foam_M2_TEST := { 
stats_dat; 
relax_volume; 
M 2; ml 6; so; find; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
flip_quads; 
pop_triangles; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; ml 6; so; find } }

relax_foam_M2_2 := { 
stats_dat; 
relax_volume; 
M 2; ml 3; so; find; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; ml 3; so; find } }

relax_foam_M1_KB := { 
stats_dat; 
relax_volume; 
ml 6; so; find; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; ml 6; so; find }; 
printf "\n      Do you want to mydump ?\n" };

relax_KBR := { sum_short_edges := 1; sJ2_tot := 1; 
while sum_short_edges > 0 or sJ2_tot > 0.00005 do { 
relax_foam_M2; go_bears_bij_KBR }; M 1; mydump }

relax_KBR := { sum_short_edges := 1; sJ2_tot := 1; 
while sum_short_edges > 0 or sJ2_tot > 0.00001 do { 
relax_foam_M2; go_bears_bij_KBR }; M 1; mydump }

relax_KBR_2 := { sum_short_edges := 1; sJ2_tot := 1; 
while sum_short_edges > 0 or sJ2_tot > 0.00005 do { 
relax_foam_M2_2; go_bears_bij_KBR }; M 1; mydump }

relax_KBR_TEST := { g5; gstep := 0; U; while scale > scale_tol and gstep < gn do { g; gstep := gstep + 1 }; U; 
so; find; 
while ( nse > 0 and same_structure <= 2 ) do gogo; 
sum_short_edges := 1; sJ2_tot := 1; 
while sum_short_edges > 0 or sJ2_tot > 0.00005 do { 
relax_foam_M2; go_bears_bij_KBR }; M 1; mydump }

relax_shear_KB := { 
so; find; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
M 2; ml 6; so; find }; 
M 1; 
mydump }

// BEGINNING of shear_flow stuff

if read_SF == 1 then { 

// 2/3/2004
shear_flow_old := { 

	deltaE := 10^(-5);
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := 0.01*Ebar;
	minL := 1;

	yzshr := 0.01; print_stuff_1; 
	printf "  deltaE = %g\n", deltaE >> "data_shear"; 
	printf "\n" >> "data_shear"; 
	center_face_vertex; relax_volume; g 20; minE; he; wd; minL := 1; 
	printf "\n" >> "data_shear"; 
	if strain < yzshr/2 then printf "#  %s    phi = %g  theta = %g  psi = %g\n", 
	datafilename, phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_summary"; 
	if strain > yzshr then printf "#\n" >> "data_shear_summary"; 

	old_energy := 1000000; old_minL := 1000000; 
	M 2; 

	while ( minL > do_T1 ) do { pbij; iterate := 1; 

	while iterate != 0 do { 
	old_energy := total_energy; ii := 1; 
	while ii <= 1 do { U; g30; U; ii := ii + 1; if scale < e_scale_tol then ii := 6 }; 
	bij; set_strain; he; wd; 
	printf "\n"; print strain; print old_energy; print total_energy; print minL; print do_T1; printf "\n";
	if iterate==3 and (minL < do_T1) then iterate := 0 ;
	if iterate==1 then { if (old_energy - total_energy < deltaE) then iterate := 2 };
	if iterate==2 and (old_minL < minL) then iterate := 0 ;
	if iterate==2 and (minL < do_T1) then iterate := 3 ;
	if ( scale < 0.001 ) then iterate := 0;
	old_energy := total_energy; old_minL := minL };

	printf "\n" >> "data_shear";
	pminE; wp_summary; 

	if minL > do_T1 then { M 1; center_face_vertex; shrmat; M 2}; 

	old_energy := 1000000; old_minL := 1000000 };

so; find; 

same_structure := 0; minL := 0;

while (nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
stats_dat; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 

	old_energy := 1000000; iterate := 1; 
	M 2; 
	printf "\n" >> "data_shear"; 

	deltaE_relax := deltaE/10;

	while iterate != 0 do { 
	old_energy := total_energy; ii := 1; 
	while ii <= 1 do { U; g30; U; ii := ii + 1; if scale < e_scale_tol then ii := 6 }; 
	bij; set_strain; he; wd; 
	printf "\n"; print strain; print old_energy; print total_energy; print minL; print do_T1; printf "\n";
	if (old_energy - total_energy < deltaE_relax) then iterate := 0;
	if ( scale < 0.000001 ) then iterate := 0;
	old_energy := total_energy };
so; find }; M 1; mydump };

// 2/10/2004
shear_flow := { 

//	deltaE := 10^(-5);
        deltaE := 10^(-7);
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := 0.01*Ebar;
	minL := 1;
	tol_05;
	yzshr := 0.01;

	print_stuff_1; printf "  deltaE = %g\n", deltaE >> "data_shear"; printf "\n" >> "data_shear"; 
	center_face_vertex; relax_volume; g 20; minE; he; wd; minL := 1; 
	printf "\n" >> "data_shear"; 
	if strain < yzshr/2 then printf "#  %s    phi = %g  theta = %g  psi = %g\n", 
	datafilename, phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_summary"; 
	if strain > yzshr then printf "#\n" >> "data_shear_summary"; 

	old_energy := 1000000; old_minL := 1000000; 
	M 2; 

	while ( minL > do_T1 ) do { pbij; iterate := 1; 

	while iterate != 0 do { 
	old_energy := total_energy; ii := 1; 
	while ii <= 1 do { U; g30; U; ii := ii + 1; if scale < e_scale_tol then ii := 6 }; 
	bij; set_strain; he; wd; 
	printf "\n"; print strain; print old_energy; print total_energy; print minL; print do_T1; printf "\n";
	if iterate==3 and (minL < do_T1) then iterate := 0 ;
	if iterate==1 then { if (old_energy - total_energy < deltaE) then iterate := 2 };
	if iterate==2 and (old_minL < minL) then iterate := 0 ;
	if iterate==2 and (minL < do_T1) then iterate := 3 ;
	if ( scale < 0.001 ) then iterate := 0;
	old_energy := total_energy; old_minL := minL };

	printf "\n" >> "data_shear";
	pminE; wp_summary; 

	if minL > do_T1 then { M 1; center_face_vertex; shrmat; M 2}; 

	old_energy := 1000000; old_minL := 1000000 };

so; find; 

while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; ml 6; so; find }; 

M 1; mydump };

// 2/6/2004

shear_flow_r1 := { 

wdr := {stresses; minL_r1; wp}; 

wpr_summary := {stresscalc; minL_r1; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear_summary"}; 

tol_01      := { ELtol:=0.01; ELtolv2:=ELtol/10; FAtol:=ELtol^2; scale_tol:=0.1; gn:=100 };
tol_01;

	deltaE := 10^(-5);
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := ELtol*Ebar;
	minL := 1;
	yzshr := 0.005;

	print_stuff_1; printf "  deltaE = %g\n", deltaE >> "data_shear"; printf "\n" >> "data_shear"; 

	center_face_vertex; 
	relax_volume; 
	g 20;    minE; he; wd; 
	M 2; gu; minE; he; wd; 
	r; gu;   minL_r1;  wdr; 

	printf "\n" >> "data_shear"; 
	if strain < yzshr/2 then printf "#  %s    phi = %g  theta = %g  psi = %g\n", 
	datafilename, phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_summary"; 
	if strain > yzshr then printf "#\n" >> "data_shear_summary"; 

mgr :=  { gu;
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := ELtol*Ebar;
	minL_r1;
	wdr };

while ( minL > do_T1 ) do { pbij; set_strain; 

	mgr 5;

	printf "\n" >> "data_shear"; wpr_summary; 

//	if minL > do_T1 then shrmat; 
	if minL > do_T1 then { M 1; center_face_vertex; shrmat; M 2}; 
	};

M 1; sft; fc; ce; cf; sod; plateau; 

so; find; 

while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
stresses; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; ml 6; so; find }; 

M 1; mydump }

}

// END of shear_flow stuff

//********************************************************************************
//********************************************************************************
//********************************************************************************

wih := {printf "  " >> "data_hyper"; 
printf datafilename >> "data_hyper"; 
printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_hyper"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_hyper"; 
pbij; 
minE; 
printf "  strain tot_energy       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_hyper"; 
fc0 := facet_count}; 

whe := {stresscalc; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_hyper"}; 

hyper_summary := {stresscalc; minE; 
sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%8.4f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
strain, total_energy, Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_hyper_summary"}; 

wh := {stresses; minE; whe}; 

hyper_elastic := { 

//	deltaE := 10^(-6);
	deltaE := 10^(-5);
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := 0.01*Ebar;
	minL := 1;
	tol_01;
	yzshr := 0.01;

	wih; printf "  deltaE = %g\n", deltaE >> "data_hyper"; printf "\n" >> "data_hyper"; 
	center_face_vertex; relax_volume; g 20; minE; he; wh; minL := 1; 
	printf "\n" >> "data_hyper"; 
	if strain < yzshr/2 then printf "#  %s    phi = %g  theta = %g  psi = %g\n", 
	datafilename, phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_hyper_summary"; 
	if strain > yzshr then printf "#\n" >> "data_hyper_summary"; 

	old_energy := 1000000; old_minL := 1000000; 
	M 2; 

	while ( minL > do_T1 ) do { pbij; iterate := 1; 

	while iterate != 0 do { 
	old_energy := total_energy; ii := 1; 
	while ii <= 1 do { U; g30; U; ii := ii + 1 }; 
	bij; set_strain; he; wh; 
//	printf "\n"; print strain; print old_energy; print total_energy; print minL; print do_T1; printf "iterate = \n", iterate; printf "\n";
	if iterate==3 and (minL < do_T1) then iterate := 0 ;
	if iterate==2 and (old_minL < minL) then iterate := 0 ;
	if iterate==2 and (minL < do_T1) then iterate := 3 ;
	if iterate==2 and old_energy - total_energy < deltaE/100 then iterate := 0 ;
//	if iterate==2 and old_energy - total_energy < deltaE/10 then iterate := 0 ;
	if iterate==1 then { if (old_energy - total_energy < deltaE) then iterate := 2 };
	if ( scale < 0.01 ) then iterate := 0;
	old_energy := total_energy; old_minL := minL };

	printf "\n" >> "data_hyper";

	minE; if minL < do_T1 then { 
	printf " Ebar = %g  MinEid = %g  minL = %g\n", Ebar, MinEid, minL; 
	printf " Ebar = %g  MinEid = %g  minL = %g\n", Ebar, MinEid, minL >> "data_hyper"; 
	list edges where ( valence == 3 and length < Ebar/10 and length < Ebar/100); 
	list edges where ( valence == 3 and length < Ebar/10 and length < Ebar/100) >> "data_hyper" };

	hyper_summary; 

//	if minL >= do_T1 then shrmat; 
	if minL >= do_T1 then { M 1; center_face_vertex; relax_volume; shrmat; M 2}; 

	old_energy := 1000000; old_minL := 1000000 };
}

step_strain := { 

	deltaE := 10^(-5);
	Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1);
	do_T1 := 0.01*Ebar;
	minL := 1;
	tol_01;
	yzshr := 0.1;

	wih; printf "  deltaE = %g\n", deltaE >> "data_hyper"; printf "\n" >> "data_hyper"; 
	center_face_vertex; relax_volume; g 20; minE; he; wh; minL := 1; 
	printf "\n" >> "data_hyper"; 
	if strain < yzshr/2 then printf "#  %s    phi = %g  theta = %g  psi = %g\n", 
	datafilename, phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_hyper_summary"; 
	if strain > yzshr then printf "#\n" >> "data_hyper_summary"; 

	old_energy := 1000000; old_minL := 1000000; 
	shrmat; M 2; ggg := {U; g30; U; bij; set_strain; he; wh; hyper_summary } 
}

count_big_nabors := { 
define body attribute big_nabors real;
define body attribute small_nabors real;

foreach body bb where volume > x_large do {set bb.facet color red};

foreach facet ff where (ff.color==red and sum(ff.body where volume > x_large,1)==2 ) do set ff.color green;

foreach body bb where min(bb.facets ff, ff.color==red) do printf "   %g   %g\n", bb.id, bb.bbf;

foreach body bb where volume > x_large do { print sum(bb.facets where color==green,1)};

foreach body bb where volume > x_large do { printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, sum(bb.facets where color==green,1/poly), sum(bb.facets where color==green,1)};

foreach body bb where volume > x_large do { set bb.big_nabors sum(bb.facets where color==green, 1/poly) };

foreach body bb where volume > x_large do { set bb.small_nabors sum(bb.facets where color==red, 1/poly) };

foreach body bb where volume < x_large do { set bb.big_nabors   sum(bb.facets where color==red, 1/poly) };

foreach body bb where volume < x_large do { set bb.small_nabors  sum(bb.facets where color==11, 1/poly) };

printf "# %s\n", datafilename >> "bi_nabor_stats.dat"; 

	bignabors := 0; 
	while bignabors < 20 do { 
	bnp := bignabors + 0.5;
	bnm := bignabors - 0.5;

	foreach body bb where ( bb.volume > x_large and bb.big_nabors > bnm and bb.big_nabors < bnp ) do { 
	printf "   %g   %g   %g\n", bb.id, bb.bbf, big_nabors; 
	printf "   %g   %g   %g\n", bb.id, bb.bbf, big_nabors >> "bi_nabor_stats.dat" }; 

	bignabors := bignabors + 1 }; 
}

count_big_big := { 
define body attribute big_nabors real;
define body attribute small_nabors real;

foreach body bb where volume > x_large do {set bb.facet color red};

foreach facet ff where (ff.color==red and sum(ff.body where volume > x_large,1)==2 ) do set ff.color green;

foreach body bb where min(bb.facets ff, ff.color==red) do printf "   %g   %g\n", bb.id, bb.bbf;

foreach body bb where volume > x_large do { print sum(bb.facets where color==green,1)};

foreach body bb where volume > x_large do { printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, sum(bb.facets where color==green,1/poly), sum(bb.facets where color==green,1)};

foreach body bb where volume > x_large do { set bb.big_nabors sum(bb.facets where color==green, 1/poly) };

foreach body bb where volume > x_large do { set bb.small_nabors sum(bb.facets where color==red, 1/poly) };

foreach body bb where volume < x_large do { set bb.big_nabors   sum(bb.facets where color==red, 1/poly) };

foreach body bb where volume < x_large do { set bb.small_nabors  sum(bb.facets where color==11, 1/poly) };

printf "# %s\n", datafilename >> "big_big.dat"; 

	foreach body bb where ( bb.volume > x_large and bb.big_nabors > bb.bbf - 0.5 ) do { 
	printf "   %g   %g   %g\n", bb.id, bb.bbf, big_nabors; 
	printf "   %g   %g   %g\n", bb.id, bb.bbf, big_nabors >> "big_big.dat" }; 
}

count_small_nabors := { 
printf "# %s\n", datafilename >> "isolated_small.dat";
printf "# %s\n", datafilename >> "small_small.dat";
define body attribute big_nabors real;
define body attribute small_nabors real;
foreach body bb where volume < x_large do {set bb.facet color red};
foreach facet ff where (ff.color==red and sum(ff.body where volume < x_large,1)==2 ) do set ff.color green;
foreach body bb where min(bb.facets ff, ff.color==red) do printf "   %g   %g\n", bb.id, bb.bbf;
foreach body bb where volume < x_large do { set bb.big_nabors   sum(bb.facets where color==red, 1/poly) };
foreach body bb where volume < x_large do { set bb.small_nabors  sum(bb.facets where color==green, 1/poly) };
print sum(body bb where (bb.volume < x_large and bb.small_nabors==0 ),1);
foreach body bb where (bb.volume < x_large and bb.small_nabors==0 ) do printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, bb.big_nabors, bb.small_nabors;
foreach body bb where (bb.volume < x_large and bb.small_nabors==0 ) do printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, bb.big_nabors, bb.small_nabors >> "isolated_small.dat";
foreach body bb where (bb.volume < x_large and bb.big_nabors==0 ) do printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, bb.big_nabors, bb.small_nabors;
foreach body bb where (bb.volume < x_large and bb.big_nabors==0 ) do printf "   %g   %g   %g   %g\n", bb.id, bb.bbf, bb.big_nabors, bb.small_nabors >> "small_small.dat";
}

bi_bar := { F_stats; printf "\n"; 
print sum(body where target < 1,bbf)/sum(body where target < 1,1);
print sum(body where target > 1,bbf)/sum(body where target > 1,1);
print sum(body where target < 1,1) + sum(body where target > 1,1);
print sum(body where target > 1,1)/sum(body,1);
printf "%8.4f%10.4f%10.4f  %s\n", 
sum(body where target > 1,1)/sum(body,1), 
sum(body where target < 1,bbf)/sum(body where target < 1,1), 
sum(body where target > 1,bbf)/sum(body where target > 1,1), 
datafilename >> "bi_bar.dat" }

//      March 11, 2005
//      April 14, 2005
 
foam_coarsening_2 := {
define body attribute GR real;
define body attribute my_target real;
printf "#  %s\n", datafilename >> "coarsen.dat";
printf "#  %s\n", datafilename >> "coarsen_summary.dat";
 
stop_coarsening := 0; D_time := 0; minL := 1; gc := { gu; g5; he; minE };
gcp := { gc; F_stats; printf "\n  %8.4f%11.7f%10.6f%9.4f%10.6f\n\n", D_time, total_energy, minL, scale, epsilon;
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f\n", D_time, total_energy, minL, scale, epsilon >> "coarsen.dat"; };
stats_dat;
 
D_step := 0.05;
 
cell_GR := { foreach body bb do { bbPA := 0;
        foreach bb.facet ff do {
        if bb.id == ff.body[1].id then neighbor := ff.body[2].id else neighbor := ff.body[1].id;
        delta_bbPA := ( bb.pressure - body[neighbor].pressure ) * ff.area * body_count/4;
        bbPA := bbPA + delta_bbPA; };
        set bb.GR -bbPA; } };
 
relax_coarsening_foam := { so; find;
while ( nse > 0 ) do {
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n";
M 1; pop_triangles; flip_quads; pop_edges; so;
sft; fc; ce; cf; sod; plateau; stresses; stats_dat; set_face_type; my_compare; matzke;
 
g3; M 2; gcp 6;
 
printf "#\n" >> "coarsen.dat";
F_stats;
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f\n", D_time, total_energy, minL, scale, epsilon >> "coarsen_summary.dat";
so; find };
 
M 1;
mydump;
dmpfn := sprintf "foam%g.fe", nndmp;
printf "nndmp := %g\n", nndmp >> dmpfn;
printf "D_time := %g\n", D_time >> dmpfn;
M 2;
};
 
coarsen_step := { if D_time >= 0.50 then D_step := 0.01;
D_time := D_time + D_step;
cell_GR;
 
print sum(body,volume); print sum(body,target); print sum(body,my_target); print sum(body,old_target); print body[1].target;
 
set body[1].target sum(body,volume) - sum(body where id != 1,target);
 
print sum(body,volume); print sum(body,target); print sum(body,my_target); print sum(body,old_target); print body[1].target;
 
//      if sum(body,volume) != sum(body,target) then set body[1].target sum(body,volume) - sum(body,target);
 
foreach body bb do {
        set bb.my_target target;
 
//      set bb.old_target bb.my_target + bb.GR * D_step;
        set bb.old_target ((bb.my_target)^(2/3) + 2/3 * bb.GR * D_step)^(3/2);
 
        if bb.old_target <= 0 then {
        printf " new body %g volume is %9.6f\n", bb.id, bb.old_target;
        printf "#  new body %g volume is %9.6f\n", bb.id, bb.old_target >> "coarsen.dat";
        stop_coarsening := 1; }; };
 
if stop_coarsening == 0 then {
 
fix_volumes := sum(body,volume)/sum(body,old_target);
printf "\n fix_volumes = %14.12f\n\n", fix_volumes;
foreach body bb do set bb.old_target bb.old_target*fix_volumes;
print sum(body,volume); print sum(body,target); print sum(body,my_target); print sum(body,old_target); print body[1].target;
 
foreach body bb do set bb.target bb.old_target;
unset body[1].target;
V; g 3; gcp 6;
printf "#\n" >> "coarsen.dat";
F_stats;
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f\n", D_time, total_energy, minL, scale, epsilon >> "coarsen_summary.dat";
histogram(body, volume); };
};
 
relax_volume;
 
M 2;
 
gcp 6;
printf "#\n" >> "coarsen.dat";
F_stats;
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f\n", D_time, total_energy, minL, scale, epsilon >> "coarsen_summary.dat";
while (stop_coarsening == 0 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ;
 
M 1;
mydump;
dmpfn := sprintf "foam%g.fe", nndmp;
printf "nndmp := %g\n", nndmp >> dmpfn;
printf "D_time := %g\n", D_time >> dmpfn;
 
}

//	April 15, 2005
//	April 18, 2005
//	April 19, 2005
//	April 20, 2005
//	May 5, 2005
//	May 18, 2005
//	June 30, 2005
//	July 21, 2005
//	August 9, 2005

foam_coarsening := { 
define body attribute GR real; 
define body attribute my_target real; 

printf "#  %s\n", datafilename >> "coarsen.dat"; 
printf "  D_time     energy      minL    scale         p cells\n" >> "coarsen.dat"; 

printf "#  %s\n", datafilename >> "coarsen_summary.dat"; 
printf "  D_time     energy      minL    scale         p cells\n" >> "coarsen_summary.dat";

printf "#  %s\n#\n", datafilename >> "coarsen_stats.dat"; 
printf "   D_time last_energy       p      <F> #faces   3    4    5    6   7  8  9 10 >10 #cells   4  5  6  7  8  9  10    11  12  13  14  15  16  17  18 19 20   21 22 23 24 24 25 27 28 29 30 >30\n" >> "coarsen_stats.dat";

/*

epsilon, sum(body,bbf)/sum(body,1), sum(body,bbf)/2 ;
printf "%9.4f %9.6f %9.6f %8.4f%7g", D_time, last_total_energy, epsilon, sum(body,bbf)/sum(body,1), sum(body,bbf)/2 ;

printf "%4g%5g%5g%5g%4g%3g%3g%3g%4g",
sum(facet ff where min(ff.edge ee, ee.valence>=3),1) + sum(vertices vv where (sum(vv.edge where valence==2,1)==3 and sum(vv.edge,1)==3 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==4 and sum(vv.edge,1)==4 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==5 and sum(vv.edge,1)==5 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==6 and sum(vv.edge,1)==6 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==7 and sum(vv.edge,1)==7 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==8 and sum(vv.edge,1)==8 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==9 and sum(vv.edge,1)==9 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)==10 and sum(vv.edge,1)==10 ),1),
sum(vertices vv where (sum(vv.edge where valence==2,1)> 10 and sum(vv.edge,1)==sum(vv.edge where valence==2,1)),1);
printf "%7g %3g%3g%3g%3g%3g%3g%4g  %4g%4g",
sum(body,1), sum(body where bbf==4,1), sum(body where bbf==5,1), sum(body where bbf==6,1), sum(body where bbf==7,1),
sum(body where bbf==8,1), sum(body where bbf==9,1), sum(body where bbf==10,1), sum(body where bbf==11,1), sum(body where bbf==12,1);
printf "%4g%4g%4g%4g%4g%4g%3g%3g  %3g%3g",
sum(body where bbf==13,1), sum(body where bbf==14,1), sum(body where bbf==15,1), sum(body where bbf==16,1), sum(body where bbf==17,1),
sum(body where bbf==18,1), sum(body where bbf==19,1), sum(body where bbf==20,1), sum(body where bbf==21,1), sum(body where bbf==22,1);
printf "%3g%3g%3g%3g%3g%3g%3g%3g%4g\n",
sum(body where bbf==23,1), sum(body where bbf==24,1), sum(body where bbf==25,1), sum(body where bbf==26,1), sum(body where bbf==27,1),
sum(body where bbf==28,1), sum(body where bbf==29,1), sum(body where bbf==30,1), sum(body where bbf >30,1);
};

F_stats; coarsen_stats; coarsen_stats >> "coarsen_stats.dat";

*/

// initial_body_count := 64;
// initial_body_count := 125;
// initial_body_count := 216; 
// initial_body_count := 512; 
initial_body_count := 1000;
set facet tension 2/initial_body_count; 

stop_coarsening := 0; did_T1 := 0; minL := 1; did_cell_GR := 0; gc := { gu; g5; he; minE }; 
gcp := { gc; F_stats; printf "\n  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n\n", D_time, total_energy, minL, scale, epsilon, sum(body,1); 
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen.dat"; }; 

last_total_energy := total_energy; 

coarsen_stats := { 

printf "%9.4f %9.6f %9.6f %8.4f%7g", D_time, last_total_energy, epsilon, sum(body,bbf)/sum(body,1), sum(body,bbf)/2 ; 

printf "%4g%5g%5g%5g%4g%3g%3g%3g%4g", 
sum(facet ff where min(ff.edge ee, ee.valence>=3),1) + sum(vertices vv where (sum(vv.edge where valence==2,1)==3 and sum(vv.edge,1)==3 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==4 and sum(vv.edge,1)==4 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==5 and sum(vv.edge,1)==5 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==6 and sum(vv.edge,1)==6 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==7 and sum(vv.edge,1)==7 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==8 and sum(vv.edge,1)==8 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==9 and sum(vv.edge,1)==9 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==10 and sum(vv.edge,1)==10 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)> 10 and sum(vv.edge,1)==sum(vv.edge where valence==2,1)),1); 
printf "%7g %3g%3g%3g%3g%3g%3g%4g  %4g%4g", 
sum(body,1), sum(body where bbf==4,1), sum(body where bbf==5,1), sum(body where bbf==6,1), sum(body where bbf==7,1), 
sum(body where bbf==8,1), sum(body where bbf==9,1), sum(body where bbf==10,1), sum(body where bbf==11,1), sum(body where bbf==12,1); 
printf "%4g%4g%4g%4g%4g%4g%3g%3g  %3g%3g", 
sum(body where bbf==13,1), sum(body where bbf==14,1), sum(body where bbf==15,1), sum(body where bbf==16,1), sum(body where bbf==17,1), 
sum(body where bbf==18,1), sum(body where bbf==19,1), sum(body where bbf==20,1), sum(body where bbf==21,1), sum(body where bbf==22,1); 
printf "%3g%3g%3g%3g%3g%3g%3g%3g%4g\n", 
sum(body where bbf==23,1), sum(body where bbf==24,1), sum(body where bbf==25,1), sum(body where bbf==26,1), sum(body where bbf==27,1), 
sum(body where bbf==28,1), sum(body where bbf==29,1), sum(body where bbf==30,1), sum(body where bbf >30,1); 
};

F_stats; coarsen_stats; coarsen_stats >> "coarsen_stats.dat"; 

//D_step := 0.01; 
D_step := 0.05; 

//	6/29/05		verify that initial_body_count should be used instead of body_count in cell_GR

cell_GR := { foreach body bb do { bbPA := 0; 
	foreach bb.facet ff do { 
	if bb.id == ff.body[1].id then neighbor := ff.body[2].id else neighbor := ff.body[1].id; 
	delta_bbPA := ( bb.pressure - body[neighbor].pressure ) * ff.area * initial_body_count/4; 
	bbPA := bbPA + delta_bbPA; }; 
	set bb.GR -bbPA; } };

relax_coarsening_foam := { did_T1 := 1; so; find; last_total_energy := total_energy; 
	while ( minL < 0.01 ) do { 
	printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
	M 1; pop_triangles; flip_quads; pop_edges; so; 
	sft; fc; ce; cf; sod; plateau; stresses; set_face_type; my_compare; matzke; 

	set facet tension 2/initial_body_count; 

	F_stats; coarsen_stats; coarsen_stats  >> "coarsen_stats.dat"; 

	igcp := 1; minL := 1; 

	V 3; 
	center_face_vertex; 
	M 2; 
	relax_volume; 
	while (igcp <= 6 and minL > 0.01) do { gcp; last_total_energy := total_energy; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	so; find }; 

	cell_GR; did_cell_GR := 1; 

	M 1; mydump; 
	dmpfn := sprintf "foam%g.fe", nndmp; 
	printf "nndmp := %g\n", nndmp >> dmpfn; 
	printf "D_time := %g\n", D_time >> dmpfn; 
	printf "# nndmp := %g\n", nndmp >> "coarsen_stats.dat"; 
	printf "# nndmp := %g\n", nndmp >> "coarsen.dat"; 
	M 2; 
}; 

coarsen_step := { if D_time >= 1.0 or did_T1 == 1 then D_step := 0.01; 

if did_cell_GR == 0 then cell_GR else did_cell_GR := 0; 

foreach body bb do { 
	set bb.my_target target; 

if (bb.my_target)^(2/3) + 2/3 * bb.GR * D_step > 0 then { set bb.old_target ((bb.my_target)^(2/3) + 2/3 * bb.GR * D_step)^(3/2) } 
else set bb.old_target 0; 

	if bb.old_target == 0 then { 
	printf   " body %g has volume %g and %g faces\n", bb.id, bb.volume, bb.bbf; 
	printf "#  body %g has volume %g and %g faces\n", bb.id, bb.volume, bb.bbf >> "coarsen.dat"; 
	stop_coarsening := 1; }; 
}; 

printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 

if stop_coarsening == 0 then { D_time := D_time + D_step; 

	fix_volumes := sum(body,volume)/sum(body,old_target); 
	printf "\n fix_volumes = %14.12f\n\n", fix_volumes; 
	foreach body bb do set bb.old_target bb.old_target*fix_volumes; 
	printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
	sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 

	foreach body bb do set bb.target bb.old_target; 

//	unset body[1].target; 

	unset_bb_target := 1; 
	foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; }; 

	igcp := 1; minL := 1; 

//	6/30/05
//	relax_volume; g5; while (igcp <= 6 and minL > 0.0025) do { gcp; igcp := igcp + 1 }; 

	relax_volume; g5; while (igcp <= 6 and minL > 0.0100) do { gcp; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	histogram(body, volume); 
}; 

if stop_coarsening == 1 then { 

	T2_cell := 10000; T2_time := 1; 

//	foreach body bb do printf " %g %g \n", bb.id, -3/2 * bb.target^(2/3)/bb.GR; 

	foreach body bb where bb.GR < 0 do { if (-3/2 * bb.target^(2/3)/bb.GR < T2_time) then { 
	T2_cell := bb.id; T2_time := -3/2 * bb.target^(2/3)/bb.GR ; printf " %g %g %g\n", bb.id, T2_cell, T2_time } }; 

	set body[T2_cell].facets color red; 
	list facets where color==red; 
	foreach facet ff where ff.color==red do set ff.edge color red; 
	list edge where color==red; 
	delete edges where color==red; 
	dissolve body[T2_cell]; 
	fec; 

	D_time := D_time + T2_time; 

foreach body bb do { 
	set bb.my_target target; 
	set bb.old_target ((bb.my_target)^(2/3) + 2/3 * bb.GR * T2_time)^(3/2); 
	if bb.old_target <= 0 then { 
	printf "   body %g has old_target %9.6f and this is a BIG PROBLEM!\n", bb.id, bb.volume; 
	printf "#  body %g has old_target %9.6f and this is a BIG PROBLEM!\n", bb.id, bb.volume >> "coarsen.dat"; }; 
	}; 

	fix_volumes := sum(body,volume)/sum(body,old_target); 
	printf "\n fix_volumes = %14.12f\n\n", fix_volumes; 
	foreach body bb do set bb.old_target bb.old_target*fix_volumes; 
	printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
	sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 
	foreach body bb do set bb.target bb.old_target; 

	unset_bb_target := 1; 
	foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; }; 

	igcp := 1; minL := 1; 

//	6/30/05
//	relax_volume; g5; while (igcp <= 6 and minL > 0.0025) do { gcp; igcp := igcp + 1 }; 

	relax_volume; g5; while (igcp <= 6 and minL > 0.0100) do { gcp; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	histogram(body, volume); 

	stop_coarsening := 0; 
}; 
}; 

V 3; 
center_face_vertex; 
M 2; 
relax_volume; 
gcp 6; 

printf "#\n" >> "coarsen.dat"; 
F_stats; 
printf "  %8.4f%11.7f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 

if minL < 0.01 then { relax_coarsening_foam; free_discards }; 

//	8/9/05
// while ( body_count > initial_body_count/2 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam; free_discards } ; 

// while ( body_count > 199 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam; free_discards } ; 

while ( body_count > initial_body_count/2 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 
// while ( D_time < 0.95 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

M 1; 
mydump; 
dmpfn := sprintf "foam%g.fe", nndmp; 
printf "nndmp := %g\n", nndmp >> dmpfn; 
printf "D_time := %g\n", D_time >> dmpfn; 

}

// end of foam_coarsening

// coarsening_animation for Myf

coarsening_animation := { 
define body attribute GR real; 
define body attribute my_target real; 
nndmp_mfy := 0;
igcp_max := 5;

gu := {conj_grad on; g20 ; conj_grad off };

printf "#  %s\n", datafilename >> "coarsen.dat"; 
printf "#  %s\n", datafilename >> "coarsen_summary.dat"; 
printf "#  %s\n#\n", datafilename >> "coarsen_stats.dat"; 
printf "    D_time          energy      minL   scale  polydispersity  sum(body,1)\n" >> "coarsen.dat"; 

initial_body_count := 64; 
// initial_body_count := 216; 
// initial_body_count := 512; 
set facet tension 2/initial_body_count; 

stop_coarsening := 0; did_T1 := 0; minL := 1; did_cell_GR := 0; gc := { gu; g5; he; minE }; 
gcp := { gc; F_stats; printf "\n  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n\n", D_time, total_energy, minL, scale, epsilon, sum(body,1); 
printf "  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen.dat"; }; 

last_total_energy := total_energy; 

coarsen_stats := { 

printf "%9.4f %9.6f %9.6f %8.4f%7g", D_time, last_total_energy, epsilon, sum(body,bbf)/sum(body,1), sum(body,bbf)/2 ; 

printf "%4g%5g%5g%5g%4g%3g%3g%3g%4g", 
sum(facet ff where min(ff.edge ee, ee.valence>=3),1) + sum(vertices vv where (sum(vv.edge where valence==2,1)==3 and sum(vv.edge,1)==3 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==4 and sum(vv.edge,1)==4 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==5 and sum(vv.edge,1)==5 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==6 and sum(vv.edge,1)==6 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==7 and sum(vv.edge,1)==7 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==8 and sum(vv.edge,1)==8 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==9 and sum(vv.edge,1)==9 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)==10 and sum(vv.edge,1)==10 ),1), 
sum(vertices vv where (sum(vv.edge where valence==2,1)> 10 and sum(vv.edge,1)==sum(vv.edge where valence==2,1)),1); 
printf "%7g %3g%3g%3g%3g%3g%3g%4g  %4g%4g", 
sum(body,1), sum(body where bbf==4,1), sum(body where bbf==5,1), sum(body where bbf==6,1), sum(body where bbf==7,1), 
sum(body where bbf==8,1), sum(body where bbf==9,1), sum(body where bbf==10,1), sum(body where bbf==11,1), sum(body where bbf==12,1); 
printf "%4g%4g%4g%4g%4g%4g%3g%3g  %3g%3g", 
sum(body where bbf==13,1), sum(body where bbf==14,1), sum(body where bbf==15,1), sum(body where bbf==16,1), sum(body where bbf==17,1), 
sum(body where bbf==18,1), sum(body where bbf==19,1), sum(body where bbf==20,1), sum(body where bbf==21,1), sum(body where bbf==22,1); 
printf "%3g%3g%3g%3g%3g%3g%3g%3g%4g\n", 
sum(body where bbf==23,1), sum(body where bbf==24,1), sum(body where bbf==25,1), sum(body where bbf==26,1), sum(body where bbf==27,1), 
sum(body where bbf==28,1), sum(body where bbf==29,1), sum(body where bbf==30,1), sum(body where bbf >30,1); 
};

F_stats; coarsen_stats; coarsen_stats >> "coarsen_stats.dat"; 

// D_step := 0.01; 
// D_step := 0.05; 
D_step := 0.005; 
D_step_initial := D_step;

//	6/29/05		verify that initial_body_count should be used instead of body_count in cell_GR

cell_GR := { foreach body bb do { bbPA := 0; 
	foreach bb.facet ff do { 
	if bb.id == ff.body[1].id then neighbor := ff.body[2].id else neighbor := ff.body[1].id; 
	delta_bbPA := ( bb.pressure - body[neighbor].pressure ) * ff.area * initial_body_count/4; 
	bbPA := bbPA + delta_bbPA; }; 
	set bb.GR -bbPA; } };

relax_coarsening_foam := { did_T1 := 1; so; find; last_total_energy := total_energy; 
	while ( minL < 0.01 ) do { 
	printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
	M 1; pop_triangles; flip_quads; pop_edges; so; 
	sft; fc; ce; cf; sod; plateau; stresses; set_face_type; my_compare; matzke; 

	set facet tension 2/initial_body_count; 

	F_stats; coarsen_stats; coarsen_stats  >> "coarsen_stats.dat"; 

	igcp := 1; minL := 1; 

	V 3; 
	center_face_vertex; 
	M 2; 
	relax_volume; 
	while (igcp <= igcp_max and minL > 0.01) do { gcp; last_total_energy := total_energy; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	so; find }; 

	cell_GR; did_cell_GR := 1; 

   nndmp_mfy := nndmp_mfy + 1;
   dmpfn_myf := sprintf "foam_%g_%09.6f.dmp",nndmp_mfy,D_time;
   dump dmpfn_myf;

/*
	M 1; mydump; 
	dmpfn := sprintf "foam%g.fe", nndmp; 
	printf "nndmp := %g\n", nndmp >> dmpfn; 
	printf "D_time := %g\n", D_time >> dmpfn; 
	printf "# nndmp := %g\n", nndmp >> "coarsen_stats.dat"; 
	printf "# nndmp := %g\n", nndmp >> "coarsen.dat"; 
	M 2; 
*/
}; 

coarsen_step := { if D_time >= 1.0 or did_T1 == 1 then D_step := D_step_initial; 

if did_cell_GR == 0 then cell_GR else did_cell_GR := 0; 

foreach body bb do { 
	set bb.my_target target; 

if (bb.my_target)^(2/3) + 2/3 * bb.GR * D_step > 0 then { set bb.old_target ((bb.my_target)^(2/3) + 2/3 * bb.GR * D_step)^(3/2) } 
else set bb.old_target 0; 

	if bb.old_target == 0 then { 
	printf   " body %g has volume %g and %g faces\n", bb.id, bb.volume, bb.bbf; 
	printf "#  body %g has volume %g and %g faces\n", bb.id, bb.volume, bb.bbf >> "coarsen.dat"; 
	stop_coarsening := 1; }; 
}; 

printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 

if stop_coarsening == 0 then { 

   nndmp_mfy := nndmp_mfy + 1;
   dmpfn_myf := sprintf "foam_%g_%09.6f.dmp",nndmp_mfy,D_time;
   dump dmpfn_myf;

   D_time := D_time + D_step; 

	fix_volumes := sum(body,volume)/sum(body,old_target); 
	printf "\n fix_volumes = %14.12f\n\n", fix_volumes; 
	foreach body bb do set bb.old_target bb.old_target*fix_volumes; 
	printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
	sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 

	foreach body bb do set bb.target bb.old_target; 

//	unset body[1].target; 

	unset_bb_target := 1; 
	foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; }; 

	igcp := 1; minL := 1; 

//	6/30/05
//	relax_volume; g5; while (igcp <= igcp_max and minL > 0.0025) do { gcp; igcp := igcp + 1 }; 

	relax_volume; g5; while (igcp <= igcp_max and minL > 0.0100) do { gcp; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	histogram(body, volume); 
}; 

if stop_coarsening == 1 then { 

	T2_cell := 10000; T2_time := 1; 

//	foreach body bb do printf " %g %g \n", bb.id, -3/2 * bb.target^(2/3)/bb.GR; 

	foreach body bb where bb.GR < 0 do { if (-3/2 * bb.target^(2/3)/bb.GR < T2_time) then { 
	T2_cell := bb.id; T2_time := -3/2 * bb.target^(2/3)/bb.GR ; printf " %g %g %g\n", bb.id, T2_cell, T2_time } }; 

	set body[T2_cell].facets color red; 
	list facets where color==red; 
	foreach facet ff where ff.color==red do set ff.edge color red; 
	list edge where color==red; 
	delete edges where color==red; 
	dissolve body[T2_cell]; 
	fec; 

	D_time := D_time + T2_time; 

foreach body bb do { 
	set bb.my_target target; 
	set bb.old_target ((bb.my_target)^(2/3) + 2/3 * bb.GR * T2_time)^(3/2); 
	if bb.old_target <= 0 then { 
	printf "   body %g has old_target %9.6f and this is a BIG PROBLEM!\n", bb.id, bb.volume; 
	printf "#  body %g has old_target %9.6f and this is a BIG PROBLEM!\n", bb.id, bb.volume >> "coarsen.dat"; }; 
	}; 

	fix_volumes := sum(body,volume)/sum(body,old_target); 
	printf "\n fix_volumes = %14.12f\n\n", fix_volumes; 
	foreach body bb do set bb.old_target bb.old_target*fix_volumes; 
	printf " sum(body,volume)      %g\n sum(body,old_target)  %g\n sum(body,target)      %g\n sum(body,my_target)   %g\n", 
	sum(body,volume), sum(body,old_target), sum(body,target), sum(body,my_target); 
	foreach body bb do set bb.target bb.old_target; 

	unset_bb_target := 1; 
	foreach body bb do { if unset_bb_target == 1 then { unset bb.target; unset_bb_target := 0 }; }; 

	igcp := 1; minL := 1; 

//	6/30/05
//	relax_volume; g5; while (igcp <= igcp_max and minL > 0.0025) do { gcp; igcp := igcp + 1 }; 

	relax_volume; g5; while (igcp <= igcp_max and minL > 0.0100) do { gcp; igcp := igcp + 1 }; 
	igcp := 1; 

	printf "#\n" >> "coarsen.dat"; 
	F_stats; 
	printf "  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 
	histogram(body, volume); 

	stop_coarsening := 0; 

   nndmp_mfy := nndmp_mfy + 1;
   dmpfn_myf := sprintf "foam_%g_%09.6f.dmp",nndmp_mfy,D_time;
   dump dmpfn_myf;
}; 
}; 

V 3; 
center_face_vertex; 
M 2; 
relax_volume; 
gcp 6; 

printf "#\n" >> "coarsen.dat"; 
F_stats; 
printf "  %8.4f%16.12f%10.6f%9.4f%10.6f%6g\n", D_time, total_energy, minL, scale, epsilon, sum(body,1) >> "coarsen_summary.dat"; 

if minL < 0.01 then { relax_coarsening_foam }; 

//	8/9/05
// while ( body_count > initial_body_count/2 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

// while ( body_count > 199 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

// while ( body_count > initial_body_count/2 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

while    ( body_count >= 16 )                  do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

// while ( D_time < 0.95 ) do { coarsen_step; if minL < 0.01 then relax_coarsening_foam } ; 

   nndmp_mfy := nndmp_mfy + 1;
   dmpfn_myf := sprintf "foam_%g_%09.6f.dmp",nndmp_mfy,D_time;
   dump dmpfn_myf;

/*
M 1; 
mydump; 
dmpfn := sprintf "foam%g.fe", nndmp; 
printf "nndmp := %g\n", nndmp >> dmpfn; 
printf "D_time := %g\n", D_time >> dmpfn; 
*/

}

// end of coarsening_animation for Myf

body_sub_type := { printf "#  %s\n", datafilename >> "body.dat"; 

define body attribute sub_type integer; define edge attribute fafb integer; 
define vertex attribute nabor_1 integer; define vertex attribute nabor_2 integer; 

rf3; foreach facet ff where ff.poly==33 do set ff.poly 3; 

foreach body bb do { set facet.face_type 1; set edge fafb 0; set bb.facet.color red; 
set vertex.nabor_1 0; set vertex.nabor_2 0; 

foreach facet ff where ff.color==red do set ff.edge color 11; 

	rmu1n := 0; rmu2n := 0; kk := 3; 
	while kk <= 15 do { 
		rmu1n := rmu1n + kk *   bb.tp[kk]; 
		rmu2n := rmu2n + kk^2 * bb.tp[kk]; 
		kk := kk + 1 }; 
	rmu1n := rmu1n/bb.bbf; 
	rmu2n := rmu2n/bb.bbf; 
	rmu2n := rmu2n - rmu1n^2; 

foreach facet ff where ff.color==red do set ff.face_type ff.poly; 

foreach edge ee where ee.valence>=3 and ee.color==11 do { 

set ee.fafb ee.facet[1].face_type * ee.facet[2].face_type * ee.facet[3].face_type; 

if ee.facet[1].face_type == 1 then { set ee.facet[2].face_type ee.facet[3].poly; set ee.facet[3].face_type ee.facet[2].poly }; 
if ee.facet[2].face_type == 1 then { set ee.facet[1].face_type ee.facet[3].poly; set ee.facet[3].face_type ee.facet[1].poly }; 
if ee.facet[3].face_type == 1 then { set ee.facet[1].face_type ee.facet[2].poly; set ee.facet[2].face_type ee.facet[1].poly }; 

}; 

fafb_1 := 0; fafb_2 := 0; 

// foreach facet ff where ff.color==red do set ff.face_type sum(ff.edge eee where eee.valence>=3, eee.fafb)/ff.poly; 
foreach vertex vv where min(vv.facet ff,ff.color==red) do { 
fafb_1 := fafb_1 + sum(vv.facet ff, ff.face_type); 
set vv.nabor_1 sum(vv.facet ff, ff.face_type); 
 }; 
fafb_1 := fafb_1 / bb.bbf; 

foreach vertex vv where min(vv.facet ff,ff.color==red) do { fafb_2 := fafb_2 + ( sum(vv.facet ff, ff.face_type) - fafb_1 )^2 }; 
fafb_2 := fafb_2 / (bb.bbf*(6 - 12/bb.bbf)^3); 

foreach facet ff where ff.color==red do { set ff.face_type sum(ff.vertex, nabor_1) }; 

foreach edge ee where ee.valence>=3 and ee.color==11 do { 

if ee.facet[1].face_type == 1 then { temp_face_type := ee.facet[2].face_type; set ee.facet[2].face_type ee.facet[3].face_type; set ee.facet[3].face_type temp_face_type }; 
if ee.facet[2].face_type == 1 then { temp_face_type := ee.facet[1].face_type; set ee.facet[1].face_type ee.facet[3].face_type; set ee.facet[3].face_type temp_face_type }; 
if ee.facet[3].face_type == 1 then { temp_face_type := ee.facet[1].face_type; set ee.facet[1].face_type ee.facet[2].face_type; set ee.facet[2].face_type temp_face_type }; 

}; 

foreach vertex vv where min(vv.facet ff,ff.color==red) do { set vv.nabor_2 sum(vv.facet, face_type) }; 

nabor_2nd := 0; 
foreach vertex vv where min(vv.facet ff,ff.color==red) do { nabor_2nd := nabor_2nd + vv.nabor_2 }; 
nabor_2nd := nabor_2nd / bb.bbf; 

nabor_2nd_2 := 0; 
foreach vertex vv where min(vv.facet ff,ff.color==red) do { nabor_2nd_2 := nabor_2nd_2 + ( vv.nabor_2 - nabor_2nd)^2 }; 
nabor_2nd_2 := nabor_2nd_2 / (bb.bbf*(6 - 12/bb.bbf)^3); 

set bb.sub_type sum(edges where color==11,fafb); 

printf "%5g%3g%3g%3g%3g%3g%3g%10.6f%4g%6g", bb.id, tp[3], tp[4], tp[5], tp[6], tp[7], tp[8], rmu2n, bb.bbf, sum(edges where color==11,fafb); 
printf "%10.6f%11.6f%10.6f%10.6f\n", fafb_2, nabor_2nd_2, nabor_2nd / (6 - 12/bb.bbf)^3 , fafb_1 / (6 - 12/bb.bbf)^2 ;

printf "%5g%3g%3g%3g%3g%3g%3g%10.6f%4g%6g", bb.id, tp[3], tp[4], tp[5], tp[6], tp[7], tp[8], rmu2n, bb.bbf, sum(edges where color==11,fafb) >> "body.dat"; 
printf "%10.6f%11.6f%10.6f%10.6f\n", fafb_2, nabor_2nd_2, nabor_2nd / (6 - 12/bb.bbf)^3 , fafb_1 / (6 - 12/bb.bbf)^2 >> "body.dat"; 

fec }; }

//	compute normalized L_f using L = 4.1728 V^(1/3)F^(1/2) actual cell V and F

L_f := { 
foreach body bb where bb.target==0 do set bb.target sum(body,volume) - sum(body,target); 
printf "\n sum targets = %g\n\n", sum(body,target); 
// myL_f := sum( body, 4.1728 / 3 * target^(1/3) * bbf^(1/2)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(2/3) ); 
myL_f := sum( body, 4.269 / 3 * target^(1/3) * bbf^(1/2)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(2/3) ); 
print myL_f; 
printf "%10.6f  %s\n", myL_f, datafilename >> "L_f_theory.dat" 
}

//********************************************************************************
//********************************************************************************

icr1 := { phi := 0; theta := 0; psi := 0; rotmat; bij_0; hyper_elastic }
icr2 := { phi := Pi/2; theta := 0; psi := 0; rotmat; bij_0; hyper_elastic }
icr3 := { phi := 0; theta := Pi/2; psi := 0; rotmat; bij_0; hyper_elastic }
icr4 := { phi := Pi/2; theta := Pi/2; psi := -Pi/2; rotmat; bij_0; hyper_elastic }
icr5 := { phi := Pi; theta := Pi/2; psi := -Pi/2; rotmat; bij_0; hyper_elastic }
icr6 := { phi := -Pi; theta := 0; psi := 0; rotmat; bij_0; hyper_elastic }
icr7 := { phi := Pi/2; theta := Pi/2; psi := Pi/2; rotmat; bij_0; hyper_elastic }
icr8 := { phi := 0; theta := Pi/2; psi := Pi; rotmat; bij_0; hyper_elastic }

//********************************************************************************
//********************************************************************************

minE_spheres := { minL := 100; 
  Ebar := sum(edge where valence>=3, length)/sum(edge where valence>=3, 1); 
  foreach edge ee where ee.valence == 3 do { 
    if (ee.length < minL) then minL := ee.length } }; 

minE_spheres_r1 := { minL := 100; 
foreach vertex vv where sum(vv.edge where valence>=3,1)==2 do { 
    if (vv.edge_len < minL) then minL := vv.edge_len } }; 

stresses_sp := { 
Sxx := sum(facet, tension * Sxxq );
Syy := sum(facet, tension * Syyq );
Szz := sum(facet, tension * Szzq );
Sxy := sum(facet, tension * Sxyq );
Syz := sum(facet, tension * Syzq );
Szx := sum(facet, tension * Szxq );
sJ2_sp := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 );
	printf "\n  Stress for drop model\n\n";
	printf "  Sxx-Syy = %16.12f\n", Sxx-Syy;
	printf "  Syy-Szz = %16.12f\n", Syy-Szz;
	printf "  Szz-Sxx = %16.12f\n", Szz-Sxx;
	printf "      Sxy = %16.12f\n", Sxy;
	printf "      Syz = %16.12f\n", Syz;
	printf "      Szx = %16.12f\n", Szx;
	printf "      sJ2 = %16.12f\n", sJ2_sp } 

stresses_drops  := { 
Sxx_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Sxxq );
Syy_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Syyq );
Szz_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Szzq );
Sxy_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Sxyq );
Syz_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Syzq );
Szx_drop := sum(facet where tension > 1.01 * 2/body_count, tension * Szxq );
sJ2_drop := sqrt ( ((Sxx_drop-Syy_drop)^2+(Syy_drop-Szz_drop)^2+(Sxx_drop-Szz_drop)^2)/6+Sxy_drop^2+Syz_drop^2+Szx_drop^2 );
	printf "\n  Stress from drops\n\n";
	printf "  Sxx-Syy = %16.12f\n", Sxx_drop-Syy_drop;
	printf "  Syy-Szz = %16.12f\n", Syy_drop-Szz_drop;
	printf "  Szz-Sxx = %16.12f\n", Szz_drop-Sxx_drop;
	printf "      Sxy = %16.12f\n", Sxy_drop;
	printf "      Syz = %16.12f\n", Syz_drop;
	printf "      Szx = %16.12f\n", Szx_drop;
	printf "      sJ2 = %16.12f\n", sJ2_drop } 


wp_G_drop := { sJ2_sp := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_sp, minL, scale >> "data_shear_spheres"; 
printf "%10.6f%10.6f\n", G_avg, G_f >> "data_shear_spheres"; 
	sJ2_drop := sqrt ( ((Sxx_drop-Syy_drop)^2+(Syy_drop-Szz_drop)^2+(Sxx_drop-Szz_drop)^2)/6+Sxy_drop^2+Syz_drop^2+Szx_drop^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz_drop, Szx_drop, Sxy_drop, Syy_drop-Szz_drop, Szz_drop-Sxx_drop, sJ2_drop, minL, scale >> "data_shear_drop" }; 


wp_drop := {stresses_sp; stresses_drops; minE_spheres; 
	sJ2_tot := sqrt ( ((Sxx-Syy)^2+(Syy-Szz)^2+(Sxx-Szz)^2)/6+Sxy^2+Syz^2+Szx^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz, Szx, Sxy, Syy-Szz, Szz-Sxx, sJ2_tot, minL, scale >> "data_shear_spheres"; 
	sJ2_drop := sqrt ( ((Sxx_drop-Syy_drop)^2+(Syy_drop-Szz_drop)^2+(Sxx_drop-Szz_drop)^2)/6+Sxy_drop^2+Syz_drop^2+Szx_drop^2 ); 
printf "%13.7f%11.7f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%10.6f%9.4f\n", 
total_energy, 2 * sum(facet,area) / sum(body,volume), 
Syz_drop, Szx_drop, Sxy_drop, Syy_drop-Szz_drop, Szz_drop-Sxx_drop, sJ2_drop, minL, scale >> "data_shear_drop" }; 


// gs_drop := { gs; wp_spheres; wp_drop}; 
//	12/13/05
gs_drop := { gg; minE; hel; wp_drop}; 


delft_drop := { 

shrmat; relax_volume; M 2; print_stuff_1; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_drop"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_drop"; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_spheres"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_spheres"; 

// gs_drop 5; 

// N_avg := 1 ; stress_avg := 0; count_avg := 20; stress_final := 1; 

gs_drop 10; 

N_avg := 1 ; stress_avg := 0; count_avg := 20; stress_final := 1; 

while ( ( N_avg <= count_avg ) and ( scale > 0.000001 ) ) do {gg; minE; hel; stresses_sp; stresses_drops; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { stress_avg := stress_avg + sJ2_sp; E_RR := 2 * sum(facet,area) / sum(body,volume) }; 
if xyshr > 0.001 then { stress_avg := stress_avg + Sxy }; 
if yzshr > 0.001 then { stress_avg := stress_avg + Syz }; 
if zxshr > 0.001 then { stress_avg := stress_avg + Szx }; 
if xyshr > 0.001 then { stress_final := Sxy }; 
if yzshr > 0.001 then { stress_final := Syz }; 
if zxshr > 0.001 then { stress_final := Szx }; 

G_avg := stress_avg   / ( N_avg * G_gam ); 
G_f   := stress_final / G_gam ; 

wp_G_drop; 

N_avg := N_avg + 1 }; 

printf "%10.6f%12.6f%12.6f\n", G_avg, G_f, minL >> "data_G_drop"; 

M 1; set_face_vertex; };


delft_drop_2 := { 

shrmat; relax_volume; M 2; print_stuff_1; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_drop"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_drop"; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_spheres"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_spheres"; 

// gs_drop 5; 

////////////////////////
minE := minL_r1; hel := herl; minE_spheres := minE_spheres_r1; 
////////////////////////

gs_drop 10; 

N_avg := 1 ; stress_avg := 0; count_avg := 20; stress_final := 1; 

// N_avg := 1 ; stress_avg := 0; count_avg := 50; stress_final := 1; 

while ( ( N_avg <= count_avg ) and ( scale > 0.000001 ) ) do {gg; minE; hel; stresses_sp; stresses_drops; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { stress_avg := stress_avg + sJ2_sp; E_RR := 2 * sum(facet,area) / sum(body,volume) }; 
if xyshr > 0.001 then { stress_avg := stress_avg + Sxy }; 
if yzshr > 0.001 then { stress_avg := stress_avg + Syz }; 
if zxshr > 0.001 then { stress_avg := stress_avg + Szx }; 
if xyshr > 0.001 then { stress_final := Sxy }; 
if yzshr > 0.001 then { stress_final := Syz }; 
if zxshr > 0.001 then { stress_final := Szx }; 

G_avg := stress_avg   / ( N_avg * G_gam ); 
G_f   := stress_final / G_gam ; 

wp_G_drop; 

N_avg := N_avg + 1 }; 

printf "%10.6f%12.6f%12.6f\n", G_avg, G_f, minL >> "data_G_drop"; 

M 1; set_face_vertex; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { 
define vertex attribute xx0 real; 
define vertex attribute yy0 real; 
define vertex attribute zz0 real; 
p1x0:=p1x; p1y0:=p1y; p1z0:=p1z; 
p2x0:=p2x; p2y0:=p2y; p2z0:=p2z; 
p3x0:=p3x; p3y0:=p3y; p3z0:=p3z; 
set vertex xx0 x; set vertex yy0 y; set vertex zz0 z }; 

reset_structure := { 
p1x:=p1x0; p1y:=p1y0; p1z:=p1z0; 
p2x:=p2x0; p2y:=p2y0; p2z:=p2z0; 
p3x:=p3x0; p3y:=p3y0; p3z:=p3z0; 
set vertex x xx0; set vertex y yy0; set vertex z zz0; }; 

};


body_0 := 1; Ns := 11; sphere_tension := 100; 


print_it := 1; 

set_spheres := { ii := 0; jj := 0; if print_it==1 then { 
printf "#  %s\n", datafilename >> "data_shear_spheres"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_spheres"; 
printf "#  %s\n", datafilename >> "data_shear_drop"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_drop"; 
print_it := 0 };
	while ii < Ns and jj < body_count - 1 do { 
	if max(body[body_0 + jj].facet ff, ff.backcolor!=11) then { 
	printf "  A sphere is adjacent to body %g\n", body_0 + jj; 
	jj := jj + 1 };
	if min(body[body_0 + jj].facet ff, ff.backcolor==11) then { 
	set body[body_0 + jj].facet tension sphere_tension * 2 / body_count; 
	set body[body_0 + jj].facet frontcolor red; 
	jj := jj + 1; ii := ii + 1; }; 
	printf " %g   %g   %g\n", ii, jj, body_0 + jj - 1 }; 
printf "\n  There are %g spheres\n", sum(body bb where min(bb.facet ff, ff.frontcolor==red),1); fec }

set_bidisperse_spheres := { ii := 0; jj := 0; if print_it==1 then { 
printf "#  %s\n", datafilename >> "data_shear_spheres"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_spheres"; 
printf "#  %s\n", datafilename >> "data_shear_drop"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_drop"; 
print_it := 0 };
	foreach body bb where volume > 2 do { 
	set bb.facet tension sphere_tension * 2 / body_count; 
	set bb.facet frontcolor red; 
	jj := jj + 1; ii := ii + 1; }; 
	printf " %g   %g   %g\n", ii, jj, body_0 + jj - 1; 
printf "\n  There are %g spheres\n", sum(body bb where min(bb.facet ff, ff.frontcolor==red),1); fec }

set_wp_spheres := { ii := 0; jj := 0; if print_it==1 then { 
printf "#  %s\n", datafilename >> "data_shear_spheres"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_spheres"; 
printf "#  %s\n", datafilename >> "data_shear_drop"; 
printf "   tot_energy       area       Syz       Szx       Sxy   Syy-Szz   Szz-Sxx       sJ2      minL    scale\n" >> "data_shear_drop"; 
print_it := 0 };
	foreach body bb where bbf0 == 12 do { 
	set bb.facet tension sphere_tension * 2 / body_count; 
	set bb.facet frontcolor red; 
	jj := jj + 1; ii := ii + 1; }; 
	printf " %g   %g   %g\n", ii, jj, body_0 + jj - 1; 
printf "\n  There are %g spheres\n", sum(body bb where min(bb.facet ff, ff.frontcolor==red),1); fec }

relax_spheres_foam := { 
set_spheres; 
stats_dat; 
relax_volume; 
M 2; gs_spheres 10; so; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
set_spheres; 
stresses_sp; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; gs_spheres 6; so; find } }

// temp_control := 1; 

relax_spheres_drop := { 

// if temp_control == 1 then { 

set_spheres; 
stats_dat; 
relax_volume; 

// };
// temp_control := 0; 

// M 2; gs_drop 10; so; 
M 2; gs_drop 20; so; 
while ( nse > 0 and same_structure <= 2 ) do { 
printf "\n\n"; list facets where color!=11; list edges where color != black; printf "\n\n"; 
M 1; 
pop_triangles; 
flip_quads; 
pop_edges; 
so; 
sft; fc; ce; cf; sod; plateau; 
set_spheres; 
stresses_sp; 
stats_dat; 
set_face_type; 
my_compare; 
relax_volume; M 2; 

// jj := 1; jjmax := 6; 
jj := 1; jjmax := 20; 
while jj <= jjmax and scale > 0.0001 do { gs_drop; jj := jj + 1 }; 

so; find } }

go_bears_bij_spheres := { 
sum_short_edges := 1; print_stuff_1; wp_spheres; 
while ( sJ2_tot > 0.00005 and minL > 0.02 ) do { 
Gbar := 0.155 * 2 * sum(facet,area) / sum(body,volume); printf "\n      Gbar = %g\n\n", Gbar; 
relax_bij; gs_spheres 3 }; stresses; 
sum_short_edges := sum(edges ee where ee.valence>=3 and ee.length < short_edge , 1); 
fec }

//	sJ2_sp > 0.0008		12/13/05

go_bears_bij_drop := { 
sum_short_edges := 1; print_stuff_1; wp_drop; 
while ( sJ2_sp > 0.0008 and minL > 0.02 ) do { 
Gbar := 0.155 * 2 * sum(facet,area) / sum(body,volume); printf "\n      Gbar = %g\n\n", Gbar; 
// relax_bij; gs_drop 6 
relax_bij; gs_drop 20 }; 
stresses; stresses_sp; stresses_drops; 
sum_short_edges := sum(edges ee where ee.valence>=3 and ee.length < short_edge , 1); 
fec }

RR_spheres := { printf "#  %s\n", datafilename >> "data_shear_spheres"; print_stuff_1; 
sum_short_edges := 1; sJ2_tot := 1; 
while sum_short_edges > 0 or sJ2_tot > 0.00005 do { 
relax_spheres_foam; go_bears_bij_spheres }; M 1; mydump; 
dmpfn := sprintf "foam%g.fe", nndmp; 
printf "Ns := %g\n", Ns >> dmpfn; 
printf "body_0 := %g\n", body_0 >> dmpfn; 
printf "sphere_tension := %g\n", sphere_tension >> dmpfn }

//	sJ2_sp > 0.0008		12/13/05

RR_drop := { stresscalc := stresses_sp; 

printf "#  %s\n", datafilename >> "data_shear_spheres"; 
printf "#  %s\n", datafilename >> "data_shear_drop"; 
print_stuff_1; 
sum_short_edges := 1; sJ2_sp := 1; 
// 
// set_spheres; 
// stats_dat; 
// relax_volume; 
// M 2; gs_drop 30; so; 
//
while sum_short_edges > 0 or sJ2_sp > 0.0008 do { 
relax_spheres_drop; go_bears_bij_drop }; M 1; mydump; 
dmpfn := sprintf "foam%g.fe", nndmp; 
printf "Ns := %g\n", Ns >> dmpfn; 
printf "body_0 := %g\n", body_0 >> dmpfn; 
printf "sphere_tension := %g\n", sphere_tension >> dmpfn }


calc_G_drop := { stresscalc := stresses_sp; 

printf datafilename >> "data_G_drop"; 
printf "  sphere_tension = %g  ", sphere_tension >> "data_G_drop"; 

reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 

delft_drop; 

G_bar := 0; 
G_f_bar := 0; 

xyshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
yzshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 

phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
yzshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
yzshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4;  rotmat; 
yzshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 

G_bar   := G_bar   / 9; 
G_f_bar := G_f_bar / 9; 

printf "\n%10.6f%12.6f\n", G_bar, G_f_bar >> "data_G_drop"; 

F_stats; 

printf "\n%9.6f%10.6f%12.6f%13.7f%12.7f%12.6f%12.6f%12.6f%10g    %s\n", 
epsilon, rsigma/rbar, Fmu2/Fbar^2, sqrt(Fmu2/Fbar^2), E_RR, G_bar, G_bar/E_RR, G_f_bar, sphere_tension, datafilename >> "data_G_drop"; 

pbij }


calc_G_drop_reset := { stresscalc := stresses_sp; 

printf datafilename >> "data_G_drop"; 
printf "  sphere_tension = %g  ", sphere_tension >> "data_G_drop"; 

reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 


delft_drop; 

G_bar := 0; 
G_f_bar := 0; 

reset := { 
p1x0:=p1x; p1y0:=p1y; p1z0:=p1z; 
p2x0:=p2x; p2y0:=p2y; p2z0:=p2z; 
p3x0:=p3x; p3y0:=p3y; p3z0:=p3z; 
set vertex xx0 x; set vertex yy0 y; set vertex zz0 z }; 

xyshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 

reset_structure; 
phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 
reset; 

G_bar   := G_bar   / 9; 
G_f_bar := G_f_bar / 9; 

printf "\n%10.6f%12.6f\n", G_bar, G_f_bar >> "data_G_drop"; 

F_stats; 

printf "\n%9.6f%10.6f%12.6f%13.7f%12.7f%12.6f%12.6f%12.6f%10g    %s\n", 
epsilon, rsigma/rbar, Fmu2/Fbar^2, sqrt(Fmu2/Fbar^2), E_RR, G_bar, G_bar/E_RR, G_f_bar, sphere_tension, datafilename >> "data_G_drop"; 

pbij }


/*
reset_shear := { xyshr := - xyshr; yzshr := - yzshr; zxshr := - zxshr; 
shrmat; xyshr := 0; yzshr := 0; zxshr := 0 }; 

xyshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 

reset_structure; 
phi :=   Pi/4; theta := 0; psi := 0; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := 0; psi := 0; rotmat; 

phi :=      0; theta :=   Pi/2; psi := Pi/4; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := - Pi/2; psi := 0;    rotmat; 

phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4; rotmat; 
reset; 
yzshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
zxshr := G_gam; reset_structure; delft_drop; reset_shear; G_bar := G_bar + G_avg; G_f_bar := G_f_bar + G_f; 
reset_structure; 
phi := - Pi/4; theta := - Pi/2; psi := - Pi/2; rotmat; 
reset; 
*/

calc_G_drop_once := { stresscalc := stresses_sp; 

// phi :=   Pi/2;   theta := Pi/2;   psi := Pi/4; rotmat; 
phi :=   0;   theta := 0;   psi := 0; rotmat; G_gam := 0.10; 
yzshr := G_gam; 

printf "\n    phi = %g  theta = %g  psi = %g\n", 
phi*180/Pi, theta*180/Pi, psi*180/Pi >> "data_shear_spheres"; 
printf "    xyshr = %g  yzshr = %g  zxshr = %g  xstr = %g  ystr = %g  zstr = %g\n", 
xyshr,yzshr,zxshr,xstr,ystr,zstr >> "data_shear_spheres"; 

// shrmat; relax_volume; M 2; print_stuff_1; 
shrmat; M 2; print_stuff_1; 

N_avg := 1 ; stress_avg := 0; 

go_baby := { gg; minE_spheres; hel; stresses_sp; stresses_drops; 

if ( xyshr==0 and yzshr==0 and zxshr==0 ) then { stress_avg := stress_avg + sJ2_sp; E_RR := 2 * sum(facet,area) / sum(body,volume) }; 
if xyshr > 0.001 then { stress_avg := stress_avg + Sxy }; 
if yzshr > 0.001 then { stress_avg := stress_avg + Syz }; 
if zxshr > 0.001 then { stress_avg := stress_avg + Szx }; 
if xyshr > 0.001 then { stress_final := Sxy }; 
if yzshr > 0.001 then { stress_final := Syz }; 
if zxshr > 0.001 then { stress_final := Szx }; 

G_avg := stress_avg   / ( N_avg * G_gam ); 
G_f   := stress_final / G_gam ; 

wp_G_drop; 

N_avg := N_avg + 1;

print sum(facet,area)/4; print sum(body[1].facet,area); print sum(body[5].facet,area)
 }; 

// go_baby 5; M 4; go_baby 100; dump

// go_baby 5; M 4; go_baby 100; dump

// go_baby 5; r; minE := minL_r1; hel := herl; minE_spheres := minE_spheres_r1; minE; go_baby 50; r; go_baby 50

go_baby 5; r; minE := minL_r1; hel := herl; minE_spheres := minE_spheres_r1; minE; go_baby 5; r; go_baby 10

}

//********************************************************************************
//********************************************************************************

quiet off

// vt := {visibility_test}

my_compare
set_face_type
plateau
if unb != 0 then {stats_dat; fix_nontrivalent_cells; my_compare; set_face_type; plateau}

// g5; M 2; ml 6; find
// pdf_min	pdf_0
//	do_bidisperse		ratio := 	x_large := 	set_bidisperse
//	r1_relax_foam		go_bears
//	relax_lattice		go_bears_bij; mydump
// quadratic relaxation with new pop commands           relax_foam_M2           relax_foam_M1_KB
// M2 and lattice relaxation with new pop commands      relax_KBR               relax_KBR_2     (less iterations)
//                                                      relax_KBR_TEST     (uses linear Brakke pops)
// relax_volume
// center_face_vertex
// o; sft; fc; ce; cf; sod; plateau
// stresses; stats_dat; set_face_type; my_compare
// go_baby := { poly_matzke; Aboav_Weaire; r1_stats; print_metrics; coarsen }; go_baby
// go_baby_II := { poly_matzke; Aboav_Weaire; r1_stats; print_metrics; coarsen_II }; go_baby_II
// go_baby_III := { poly_matzke; Aboav_Weaire; r1_stats; print_metrics; herl; coarsen_III }; go_baby_III
// go_baby_test := { poly_matzke; Aboav_Weaire; g20; r; M 2; herl; coarsen_III }; go_baby_test
// go_baby_Vornoi := { poly_matzke; Aboav_Weaire; Voronoi_stats; print_metrics; coarsen }; go_baby
// printf "#  radius  Rk  Rk/radius  4/3*Pi*radius^3  target  target/(4/3*Pi*radius^3)\n"  >> "R_Rk.dat"
// foreach body bb do printf "%12.6f%12.6f%12.6f%12.6f%12.6f%18.6f\n", radius, Rk, Rk/radius, 4/3*Pi*radius^3, target, target/(4/3*Pi*radius^3)  >> "R_Rk.dat"
// foreach body bb do printf "%6g%4g%10.4f%14.8f%14.8f\n", bb.id, bb.bbf, bb.bbf-fbar, bb.target, bb.target-1 >> "Lewis.dat"
// old_stuff	new_stuff	list_different_large_bodies	list_different_bodies >> "different_cells.txt"
// F_stats; poly_matzke; poly_fn; matzke
// sally  := { phi := Pi/2; theta := 0; psi := 0; rotmat; bij_0; stats2 >> "stats.dat"; while strain <= 10.0 do shear_flow }
// sally  := { while strain <= 10.0 do shear_flow }
// tol_001; gstart; relax_r0; mydump; same_structure := 0; tol_01; gstart; relax_r0; mydump; same_structure := 0; tol_05; holly
// tol_001; gstart; relax_r0; same_structure := 0; tol_01; gstart; relax_r0; same_structure := 0; tol_05; holly
// step_strain
// do_bidisperse; count_big_nabors
// do_bidisperse; count_small_nabors
// do_bidisperse; count_big_big
// matzke; bi_nabor_stuff
// bi_bar
// relax_volume; M 2; gu
// R_stats; q; q
// body_sub_type
// lambda_UT := 1.3
// zstr := (lambda_UT)^(2/3); xstr := (lambda_UT)^(-1/3); ystr :=  (lambda_UT)^(-1/3); 
// strmat
// cell_vol ?
// nndmp := 
// gu := { U; g30; U; g10}
// count_Matzke_cells
// old_stuff := { old_nabor_search }
// new_stuff := { new_nabor_search; new_cells; color_new_cells }
// foreach body bb do printf " %3g %12.8f %3g\n", bbf, bb.target, bb.original >> "VF.dat"
// D_time := 0; foam_coarsening
// pSf := {Sf := 2*sum(facet,area)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(1/3); print Sf }
// pLf := {Lf := sum(edges where valence>=3,length)/sum(body,volume) * (sum(body,volume)/sum(body,1))^(2/3); print Lf }
// coarse_r1_stats
// read "volume_histogram"
// L_f
// list edges ee where sum(ee.facet ff where ff.face_type==3, 1)==3
// initial_body_count := 512; set facet tension 2/initial_body_count
// relax_volume; M 2; gu
// relax_foam_M2; linear; mydump
// go_baby := { poly_matzke; Aboav_Weaire; r1_stats; print_metrics; coarsen }; go_baby
// read "volume_histogram"
// calc_G
// foreach body bb where min(bb.facet ff, ff.tension > 2 * sfac) do set bb.facet frontcolor red
// go_bears_bij_spheres
// sphere_tension := 100; set_spheres; RR_drop
// G_gam := 0.05
// delft_drop	10 50
//	do_bidisperse		ratio := 	x_large := 	set_bidisperse
// foreach body bb where bb.volume > 2 do set bb.facet frontcolor red
// set_spheres := set_bidisperse_spheres; sphere_tension := 100; set_spheres; RR_drop
// set_spheres := set_bidisperse_spheres; set_spheres; calc_G_drop
// sphere_tension := 200; set_spheres; calc_G_drop
// cell_def := { F_stats; calc_sJ2; cell_D; cell_deformation_mono}; cell_def
// set facet color -1; set edge color -1
// foreach body bb where min(bb.facet ff, ff.tension > 2.1/body_count) do set bb.facet frontcolor red
// set_spheres; delft_drop := delft_drop_2; calc_G_drop_reset
// set_spheres; calc_G_drop_once
// minE := minL_r1; hel := herl; minE_spheres := minE_spheres_r1
// sphere_tension := 100; set_wp_spheres; calc_G_drop_once


/*
set_spheres := { ii := 0; jj := 0; 
	while ii < Ns and jj < body_count - 1 do { 
	if max(body[body_0 + jj].facet ff, ff.color==red) then { jj := jj + 1 };
	if min(body[body_0 + jj].facet ff, ff.color==11) then { 
	set body[body_0 + jj].facet tension sphere_tension * 2 / body_count; 
	set body[body_0 + jj].facet color red; 
	ii := ii + 1; printf " %g   %g\n", ii, body_0 + jj }; jj := jj + 1 }; 
printf "\n  There are %g spheres\n", sum(body bb where min(bb.facet ff, ff.frontcolor==red),1) }
*/

define body attribute nowrap integer;

UT_image_dry := { 

foreach body bb do { 
 set bb.facet color red; 
 print sum(edges ee where max(ee.facet ff, ff.color==red) and ee.wrap != 0,1); 
 if sum(edges ee where max(ee.facet ff, ff.color==red) and ee.wrap != 0,1)==0 then { 
   set bb.nowrap 1; 
   printf "      %g\n",  bb.id; 
   printf "%6g\n",  bb.id >> "unwrapped_bodies.dat"}; 
set facet color -1 };

print sum(body where nowrap==1,1);
print sum(body where nowrap==0,1);

foreach body bb where bb.nowrap >= 1 and min(bb.facet ff, ff.body[2].nowrap >= 1) do set bb.nowrap 10;

print sum(body where nowrap==10,1);
print sum(body where nowrap==1,1);
print sum(body where nowrap==0,1);

foreach body bb where bb.nowrap >= 10 and min(bb.facet ff, ff.body[2].nowrap >= 10) do set bb.nowrap 100;

print sum(body where nowrap==100,1);
print sum(body where nowrap==10,1);
print sum(body where nowrap==1,1);
print sum(body where nowrap==0,1);

foreach body bb where bb.nowrap >= 10 do { printf"  %g  %g  %g  %g\n", bb.id, sum(bb.facet ff where ff.body[1].nowrap>=10,1), sum(bb.facet ff where ff.body[2].nowrap>=10,1), 
  sum(bb.facet ff where ff.body[1].nowrap>=10,1) - sum(bb.facet ff where ff.body[2].nowrap>=10,1) };

printf "define body attribute nowrap integer\n" >> "dry_nowraps";
foreach body bb do printf "set body[%g].nowrap %g\n", bb.id, bb.nowrap >> "dry_nowraps";

};

// UT_image_dry

// relax_foam_M2; linear; mydump

// foreach facet ff where ff.original==4 do set ff.color red
// phi :=  Pi/2; theta := Pi/4; psi := -Pi/2; rotmat

G_ICR := { gp := { gu; stresses; wp}; pb := {printf "\n" >> "data_shear"}; 
//xyshr := -0.03; 
xyshr := 0; 
//yzshr := -0.03; 
yzshr := 0; 
zxshr := -0.03; 
//zxshr := 0; 
shrmat; 
print_stuff_1; 
relax_volume; 
M 2; 
gp 10; 
pb; r; gp 10; 
pb; r; gp 10; 
pb; 
e >>  "data_shear"
}
// G_ICR

// print strain
// sally  := { while strain <= 10.0 do shear_flow }

//gogo1 := { poly_matzke; Aboav_Weaire; count_Matzke_cells};
//gogo2 := { calc_sJ2_sQ; cell_D; cell_geometry};
//gogo2 := { calc_sJ2_sQ; cell_D; poly_geometry};

//cmc := count_Matzke_cells

cleanup := { 
foreach facet ff where sum(ff.edge where valence==2,1)==1 do refine ff.edge where valence==2;
fix vertex vv where sum(vv.edge where valence>=3,1)>0; 
foreach edge ee where ee.vertex[1].fixed==0 and ee.vertex[2].fixed==0 do set ee.color red; 
delete edge where color==red; 
unfix vertex; 
fix vertex vv where sum(vv.edge where valence>=3,1)>=4; 
delete edge where valence>=3; 
unfix vertex; 
}

relax_test := {
gu 5; so; cse; dce; 
o; o; cleanup; cleanup; 
foreach vertex vv where vv.valence>=3 do delete vv.edge[1]; 
plateau; 
o; o; cleanup; cleanup; 
foreach vertex vv where vv.valence>=3 do delete vv.edge[1]; 
plateau; 
sod; 
matzke; 
}

define vertex attribute lutz integer[3];

print_lutz := {
rf3 := {refine facet ff where ff.edge[1].valence>=3 and ff.edge[2].valence>=3 and ff.edge[3].valence>=3};
rf3;
foreach body bb do { 
   set vertex new_id 0; 
   set facet face_id 0; 
   nn := 1; 
   set vertex lutz[1] 0; 
   set vertex lutz[2] 0; 
   set vertex lutz[3] 0; 
   foreach bb.facet ff do { foreach ff.vertex vv where sum(vv.edge where valence>=3,1)==4 do set vv.new_id 1 };
   foreach bb.facet ff do { foreach ff.vertex vv where sum(vv.edge where valence==2,1)==sum(vv.edge,1) do set vv.new_id 2 };
   foreach vertex vv where vv.new_id==2 do {set vv.facet face_id nn; nn := nn+1};
   foreach vertex vv where vv.new_id==1 do { 
      foreach vv.facet ff where ff.face_id != 0 do 
         { if vv.lutz[1]==0 then set vv.lutz[1] ff.face_id};
      foreach vv.facet ff where ff.face_id != 0 do 
         { if vv.lutz[2]==0 and vv.lutz[1] != ff.face_id then set vv.lutz[2] ff.face_id};
      foreach vv.facet ff where ff.face_id != 0 do 
         { if vv.lutz[3]==0 and vv.lutz[1] != ff.face_id and vv.lutz[2] != ff.face_id then set vv.lutz[3] ff.face_id};
      };

print bb.id; 
// foreach vertex vv where vv.new_id==1 do print lutz;

vcount := 1; vvmax := sum(vertex where new_id==1,1); 
printf "%8g  [", bb.id >> "lutz.dat"; 
foreach vertex vv where vv.new_id==1 do {
   printf "[%g,%g,%g]", vv.lutz[1], vv.lutz[2], vv.lutz[3] >> "lutz.dat";
   if vcount <= vvmax-1 then printf "," >> "lutz.dat";
   vcount := vcount+1; };
printf "]\n" >> "lutz.dat";
   };
}

// relax_foam_M2; linear; mydump

lambda := 1.0;

calc_Q := { 
printf "\n#     %s\n",datafilename >> "claudia_Q.dat";
printf "#     lambda = %g\n", lambda >> "claudia_Q.dat";

Qxxf := sum( facet, Qxxq )/sum(body,volume);
Qyyf := sum( facet, Qyyq )/sum(body,volume);
Qzzf := sum( facet, Qzzq )/sum(body,volume);
Qxyf := sum( facet, Qxyq )/sum(body,volume);
Qyzf := sum( facet, Qyzq )/sum(body,volume);
Qzxf := sum( facet, Qzxq )/sum(body,volume);

sJ2Qf  := sqrt (((Qxxf-Qyyf)^2+(Qyyf-Qzzf)^2+(Qxxf-Qzzf)^2)/6+Qxyf^2+Qyzf^2+Qzxf^2);
printf "   sJ2Qf = %10.6f\n", sJ2Qf;
sJ2Qf  := sqrt ((Qxxf^2+Qyyf^2+Qzzf^2)/2+Qxyf^2+Qyzf^2+Qzxf^2);
printf "   sJ2Qf = %10.6f\n", sJ2Qf;

printf "#                               <Qf>          Qxxf          Qyyf          Qzzf          Qxyf          Qyzf          Qzxf\n"  >> "claudia_Q.dat";

printf "#%35.8f%14.8f%14.8f%14.8f%14.8f%14.8f%14.8f\n", sJ2Qf, Qxxf, Qyyf, Qzzf, Qxyf, Qyzf, Qzxf >> "claudia_Q.dat";

printf "# body    volume      area       <Q>           Qxx           Qyy           Qzz           Qxy           Qyz           Qzx\n"  >> "claudia_Q.dat";

define body attribute Qb real;

foreach body bb do {
Qxxb := sum( bb.facet, Qxxq )/(bb.volume)^(2/3);
Qyyb := sum( bb.facet, Qyyq )/(bb.volume)^(2/3);
Qzzb := sum( bb.facet, Qzzq )/(bb.volume)^(2/3);
Qxyb := sum( bb.facet, Qxyq )/(bb.volume)^(2/3);
Qyzb := sum( bb.facet, Qyzq )/(bb.volume)^(2/3);
Qzxb := sum( bb.facet, Qzxq )/(bb.volume)^(2/3);

sJ2Qb  := sqrt ( (Qxxb^2+Qyyb^2+Qzzb^2)/2 +Qxyb^2+Qyzb^2+Qzxb^2 );
set bb.Qb sJ2Qb;

printf "%6g%10.6f%10.6f%10.6f%14.8f%14.8f%14.8f%14.8f%14.8f%14.8f\n",
bb.id, bb.volume, sum(bb.facet,area), sJ2Qb,
Qxxb, Qyyb, Qzzb, Qxyb, Qyzb, Qzxb >> "claudia_Q.dat"};
}

calc_A := { calc_Q;

printf "\n#     %s\n",datafilename >> "claudia_A.dat";

foreach edge ee where ee.valence>=3 do set ee.color red; 

Axxf := sum( edges where color==red, Axxq )/sum(body,volume);
Ayyf := sum( edges where color==red, Ayyq )/sum(body,volume);
Azzf := sum( edges where color==red, Azzq )/sum(body,volume);
Axyf := sum( edges where color==red, Axyq )/sum(body,volume);
Ayzf := sum( edges where color==red, Ayzq )/sum(body,volume);
Azxf := sum( edges where color==red, Azxq )/sum(body,volume);

sJ2Af  := sqrt ( (Axxf^2+Ayyf^2+Azzf^2)/2 +Axyf^2+Ayzf^2+Azxf^2 );
print sJ2Af;
sJ2Af := sqrt ( ((Axxf-Ayyf)^2+(Ayyf-Azzf)^2+(Axxf-Azzf)^2)/6+Axyf^2+Ayzf^2+Azxf^2 );
print sJ2Af;

printf "#     lambda = %g     sJ2Qf = %10.6f      sJ2Af = %10.6f\n", lambda, sJ2Qf, sJ2Af >> "claudia_A.dat";
fec;

printf "#                               <Af>          Axxf          Ayyf          Azzf          Axyf          Ayzf          Azxf\n"  >> "claudia_A.dat";

printf "#%35.8f%14.8f%14.8f%14.8f%14.8f%14.8f%14.8f\n", sJ2Af, Axxf, Ayyf, Azzf, Axyf, Ayzf, Azxf >> "claudia_A.dat";

printf "# body    volume      area    edge_len       <Q>       <A>           Axx           Ayy           Azz           Axy           Ayz           Azx\n"  >> "claudia_A.dat";

foreach body bb do { 
	foreach bb.facet ff do { foreach ff.edge ee where ee.valence>=3 do set ee.color red };

Axxb := sum( edges where color==red, Axxq )/(bb.volume)^(1/3);
Ayyb := sum( edges where color==red, Ayyq )/(bb.volume)^(1/3);
Azzb := sum( edges where color==red, Azzq )/(bb.volume)^(1/3);
Axyb := sum( edges where color==red, Axyq )/(bb.volume)^(1/3);
Ayzb := sum( edges where color==red, Ayzq )/(bb.volume)^(1/3);
Azxb := sum( edges where color==red, Azxq )/(bb.volume)^(1/3);

sJ2Ab  := sqrt ( (Axxb^2+Ayyb^2+Azzb^2)/2 +Axyb^2+Ayzb^2+Azxb^2 ); 

printf "%6g%10.6f%10.6f%12.6f%10.6f%10.6f%14.8f%14.8f%14.8f%14.8f%14.8f%14.8f\n",
bb.id, bb.volume, sum(bb.facet,area), sum(edges where color==red, length)/3, 
bb.Qb, sJ2Ab, Axxb, Ayyb, Azzb, Axyb, Ayzb, Azxb >> "claudia_A.dat"; fec };
};

calc_foam_anisotropy := {
printf "#  %s\n", datafilename >> "cell_anisotropy.dat";
printf "#  lambda = %6.4f\n", lambda >> "cell_anisotropy.dat";
printf "  cell #          Dx          Dy          Dz      Dx*Dy*Dz   cell volume  surface area\n" >> "cell_anisotropy.dat";
sum_Dx := 0; sum_Dy := 0; sum_Dz := 0; sum_vol:= 0;
print p1x; print p2y; print p3z;

foreach body bb do {
      set bb.facet color red;
      foreach facet ff where ff.color==red do {foreach ff.edge ee where ee.valence>=3 do {set ee.color green}};
      foreach facet ff where ff.color==red do {foreach ff.edge ee where ee.valence>=3 and ee.wrap==0 do {set ee.color yellow}};
      foreach facet ff where ff.color==red do {foreach ff.edge ee where ee.valence>=3 do {set ee.vertex[1].new_id 1; set ee.vertex[2].new_id 1}};

jjmax := sum(vertex where new_id > 0,1);
jj := 1; jjset := 1;
while jj <= jjmax do {
      foreach edge ee where ee.color==yellow do {
              if ee.vertex[1].new_id==1 and ee.vertex[2].new_id==1 and jjset==1 then {
                set ee.vertex[1].new_id 444444; set ee.vertex[1].new_id 444444; jjset := 0 };
              if ee.vertex[1].new_id==1 and ee.vertex[2].new_id==444444 then { set ee.vertex[1].new_id 444444 };
              if ee.vertex[1].new_id==444444 and ee.vertex[2].new_id==1 then { set ee.vertex[2].new_id 444444 };
              }; jj := jj + 1};

foreach vertex vv where vv.new_id > 0 do { set vv.tx vv.x; set vv.ty vv.y; set vv.tz vv.z };
xbar := sum(vertex vv where vv.new_id > 1,vv.x)/sum(vertex where new_id > 1,1);
ybar := sum(vertex vv where vv.new_id > 1,vv.y)/sum(vertex where new_id > 1,1);
zbar := sum(vertex vv where vv.new_id > 1,vv.z)/sum(vertex where new_id > 1,1);

// print xbar; print ybar; print zbar; print p1x; print p2y; print p3z;

foreach vertex vv where vv.new_id = 1 do {
        if vv.x - xbar > p1x/2 then set vv.tx (vv.x - p1x); if vv.x - xbar < -p1x/2 then set vv.tx (vv.x + p1x);
        if vv.y - ybar > p2y/2 then set vv.ty (vv.y - p2y); if vv.y - ybar < -p2y/2 then set vv.ty (vv.y + p2y);
        if vv.z - zbar > p3z/2 then set vv.tz (vv.z - p3z); if vv.z - zbar < -p3z/2 then set vv.tz (vv.z + p3z) };
xmin := 10^6; xmax := -10^6; ymin := 10^6; ymax := -10^6; zmin := 10^6; zmax := -10^6;

foreach vertex vv where vv.new_id > 0 do {

  if vv.tx < xmin then xmin := vv.tx; if vv.tx > xmax then xmax := vv.tx;
  if vv.ty < ymin then ymin := vv.ty; if vv.ty > ymax then ymax := vv.ty;
  if vv.tz < zmin then zmin := vv.tz; if vv.tz > zmax then zmax := vv.tz };

/* list vertex where new_id != 0 >> "cell_size.dat";
printf "\n%6g  %12.6f%12.6f%12.6f  %12.6f\n\n", bb.id, xmax-xmin, ymax-ymin, zmax-zmin, (xmax-xmin)*(ymax-ymin)*(zmax-zmin) >> "cell_size.dat";

printf "%6g  %12.6f%12.6f%12.6f  %12.6f\n", bb.id, xmax-xmin, ymax-ymin, zmax-zmin, (xmax-xmin)*(ymax-ymin)*(zmax-zmin) >> "cell_anisotropy.dat";
*/

printf "%6g  %12.6f%12.6f%12.6f%14.6f%14.6f%14.6f\n", bb.id, xmax-xmin, ymax-ymin, zmax-zmin, 
(xmax-xmin)*(ymax-ymin)*(zmax-zmin), bb.volume, sum(bb.facet,area) >> "cell_anisotropy.dat";

fec; set vertex.new_id 0; set vertex.tx 0; set vertex.ty 0; set vertex tz 0;

sum_Dx := sum_Dx + xmax-xmin; sum_Dy := sum_Dy + ymax-ymin; sum_Dz := sum_Dz + zmax-zmin; sum_vol := sum_vol + (xmax-xmin)*(ymax-ymin)*(zmax-zmin); 

}; 

sum_Dx := sum_Dx/sum(body,1); sum_Dy := sum_Dy/sum(body,1); sum_Dz := sum_Dz/sum(body,1); sum_vol := sum_vol/sum(body,1);
printf "\n        %12.6f%12.6f%12.6f  %12.6f\n\n", sum_Dx, sum_Dy, sum_Dz, sum_vol >> "cell_anisotropy.dat";

printf "        Foam Anisotropy x = %8.6f\n", sum_Dx/(0.5*(sum_Dy+sum_Dz)) >> "cell_anisotropy.dat";
printf "        Foam Anisotropy y = %8.6f\n", sum_Dy/(0.5*(sum_Dz+sum_Dx)) >> "cell_anisotropy.dat";
printf "        Foam Anisotropy z = %8.6f\n", sum_Dz/(0.5*(sum_Dx+sum_Dy)) >> "cell_anisotropy.dat";
};

KU_edges := { 
printf "   %s\n", datafilename >> "KU_edge.dat";
printf "#  lambda = %6.4f\n", lambda >> "KU_edge.dat";
printf "     edge ID #           x_0         y_0         z_0           x_1         y_1         z_1        length\n" >> "KU_edge.dat";
foreach edge ee where ee.valence>=3 do {
printf "%14g  %12.6f%12.6f%12.6f  %12.6f%12.6f%12.6f  %12.6f  %12.6f\n", ee.id, ee.vertex[1].x, ee.vertex[1].y, ee.vertex[1].z, 
ee.vertex[2].x, ee.vertex[2].y, ee.vertex[2].z, ee.length, 
sqrt( (ee.vertex[1].x - ee.vertex[2].x)^2 + (ee.vertex[1].y - ee.vertex[2].y)^2 + (ee.vertex[1].z - ee.vertex[2].z)^2) >> "KU_edge.dat" };
printf "\n       histogram of edge lengths\n" >> "KU_edge.dat";
histogram(edges where valence>=3,length) >> "KU_edge.dat";
};

// gogo1 := { poly_matzke; Aboav_Weaire; count_Matzke_cells};
// gogo2 := { calc_sJ2_sQ; cell_D; poly_geometry};
// gogo := { M 2; g20 }

// Sebastian,
// for VP1728_mono_1.fe type "holly"
// for VP1728_lnd_1.0_30.fe change "cell_vol := 1" on line 20 of this file to "cell_vol := 2" 
// and type "gogo_VP" 
// gogo_VP := { relax_foam_M2; linear; mydump }
// Myf, type "gogo1" and then "gogo" and/or other relaxation commands 
// and then "gogo2" to get the output files
// coarsening_animation
// print_lutz

// Durham stuff

/*
vol_stats := { F_stats; minE; Sbar := 2*sum(facet,area)/sum(body,volume); ELbar := sum(edge where valence>=3,length)/sum(body,volume); 
printf "\n %10.6f%10.6f%10.6f%7.3f%10.6f%10.6f%10.6f%10.6f  %s\n",epsilon,rsigma/rbar,volsigma/volbar,Fbar,Sbar,ELbar,Ebar,minL,datafilename; 
  printf " %10.6f%10.6f%10.6f%7.3f%10.6f%10.6f%10.6f%10.6f  %s\n",epsilon,rsigma/rbar,volsigma/volbar,Fbar,Sbar,ELbar,Ebar,minL,datafilename >> "volume_stats.dat" };

volume_stats := {polydisperse; F_stats; vol_stats}; 
*/

// gogo := {relax_foam_M2; linear; mydump}

// volume_stats; mydow
// volume_stats; gogo
// volume_stats

// gogo1 := { poly_matzke; Aboav_Weaire; count_Matzke_cells};
// gogo2 := { calc_sJ2_sQ; cell_D; poly_face};
// gogo := { M 2; g20; gu 5; g20; r; g20; gu 5; g20}
rfm := {read "foam.my"}
// gobaby := {gogo1; gogo; gogo2}
// sally := {matzke; stats; matzke }
// relax_foam_M2; linear; mydump
// gobaby := {sally; gogo1; gogo; gogo2}
// gobaby := {linear; sally; gogo1; gogo; gogo2}
// ppfn := {printf "\n%s\n", datafilename >> "pfn.dat"; matzke >> "pfn.dat"}
// calc_Q

// old_stuff := {print strain; old_nabor_search}
// new_stuff := {new_nabor_search; new_cells; color_new_cells}
// type_stuff := {matzke; ppfn; stats; poly_types}
// ppfn
// print strain; type_stuff; new_stuff; s

// kelvin_classic := { phi := 0; theta := atan(1); psi := atan(sqrt(2)); rotmat; 
// bij_0; stats2 >> "stats.dat"; while strain <= 2.0 do shear_flow }

vol_stats := { F_stats; minE; Sbar := 2*sum(facet,area)/sum(body,volume); ELbar := sum(edge where valence>=3,length)/sum(body,volume);
printf "\n %10.6f%10.6f%10.6f%7.3f%10.6f%10.6f%10.6f%10.6f  %s\n",epsilon,rsigma/rbar,volsigma/volbar,Fbar,Sbar,ELbar,Ebar,minL,datafilename;
  printf " %10.6f%10.6f%10.6f%7.3f%10.6f%10.6f%10.6f%10.6f  %s\n",epsilon,rsigma/rbar,volsigma/volbar,Fbar,Sbar,ELbar,Ebar,minL,datafilename >> "volume_stats.dat" };

volume_stats := {polydisperse; F_stats; vol_stats};

// gobaby
// volume_stats

UT := {quadratic; g20; gu; he; linear; he}
// read "edge_lengths"

// read "saveFoamCharact_surf.c"
// read "saveFoamCharact_andy.c"

// cmc := count_Matzke_cells

// gogo := { M 2; g20; gu 5; g20; r; g20; gu 5; g20}

gogo := {relax_foam_M2; linear; mydump}

// type "print_lutz"

// to relax a Voronoi or Laguerre tessellation
// for a monodisperse structure set cell_vol := 1 at the top of this file 
// evolver V*.fe
// holly

// after the script runs rename foam1.fe to R*.fe
// to anneal the structure and create 3N structures
// evolver R*.fe
// cycle N   
// rename foamM.fe to R..._cM.fe -- the cM indicates that it is the M_th structure created by annealing

// to relax a foam R*.fe using quadratic facets
// run the evolver R*.fe
// gogo
// rename foam1.fe to RR*.fe -- this file should be stable when run in quadratic mode, which is invoked by typing quadratic or M2

// to similate foam coarsening
// remember to set initial_body_count in under the script foam_coarsening above
// run the evolver
// D_time := 0; foam_coarsening -- D_time := 0 sets the initial coarsening time D_time to 0

// the coarsening simulation produces new structures after each successful T1 cascade
// to restart the simulation from a structure foamN.fe
// evolver foamN.fe -- the time D_time is set at the bottom of this fils so you don't have to specify it to restart the sumilation.
// Just type
// foam_coarsening

// holly
// gogo
// cycle 10
// calc_A

gobaby := {phi := pi/2; theta := pi/2; rotmat; stretch; strmat; M 2; g20; gu; g20; he; r; V 5; gu 3; g20}
gobaby := {phi := pi/2; theta := pi/2; rotmat; stretch; strmat}

vt := {visibility_test}

// stavros_stats        to write stavros_metrics.dat
// set psstmp := 1 if you want to label the columns in stavros_metrics.dat
psstmp := 1;

lambda := 1;
stretch_z := { lambda := 1.2;
zstr := lambda; xstr := 1/sqrt(lambda); ystr := xstr };
stretch_y := { lambda := 1.05;
ystr := lambda; zstr := 1/sqrt(lambda); xstr := zstr };
stretch_x := { lambda := 1.05;
xstr := lambda; zstr := 1/sqrt(lambda); ystr := zstr };
// strmat

// UTA := {quadratic; g20; gu; he; calc_A}
// UTB := {strmat; quadratic; g20; gu; r; gu 3; g20; he; calc_A}
// UTC := {quadratic; g20; gu; g20; he; linear; mydump}
// UTD := {strmat; calc_A; mydow}
// UTE := {calc_A; mydow}
// UTF := {mydow; calc_A; calc_foam_anisotropy}

// stretch_z; strmat; mydow
// stretch_z; strmat; calc_A
// stretch_z; strmat; calc_foam_anisotropy
// stretch_z; strmat; mydow; calc_A; calc_foam_anisotropy
// stretch_z; strmat; UTC

// stretch_x; strmat; calc_A; calc_foam_anisotropy
// stretch_y; strmat; calc_A; calc_foam_anisotropy

// vt; stavros_stats

// commands for Markus and Claudia

stretch_z := { zstr := lambda; xstr := 1/sqrt(lambda); ystr := xstr };
stretch_y := { ystr := lambda; zstr := 1/sqrt(lambda); xstr := zstr };
stretch_x := { xstr := lambda; ystr := 1/sqrt(lambda); xstr := ystr };

// to stretch a foam affinely, e.g. RRP1728_mono_1_c196.fe or any fe file without lam in the name, 
// and calculate cell shapes and foam anisotropy, 
// set lambda := 1.** and run one of the following commands (with the appropriate value of lambda)
// by removing "//"

// lambda := 1.1; stretch_z; strmat; calc_A; calc_foam_anisotropy; KU_edges
// lambda := 1.1; stretch_x; strmat; calc_A; calc_foam_anisotropy; KU_edges
// lambda := 1.1; stretch_y; strmat; calc_A; calc_foam_anisotropy; KU_edges

bi_stuff := { 
print sum(body where volume < 1,volume)/sum(body where volume < 1,1);
print sum(body where volume > 1,volume)/sum(body where volume > 1,1);
print (sum(body where volume > 1,volume)/sum(body where volume > 1,1))/(sum(body where volume < 1,volume)/sum(body where volume < 1,1));
}

// do_bidisperse; set_bidisperse
//      do_bidisperse           ratio :=        x_large :=      set_bidisperse

cmc := count_Matzke_cells

/*
kelvin_quad_flat := {
mykb := 1/2^(2/3);
flat := {
define vertex attribute film_1 integer;
foreach facet ff where ff.original==1 do set ff.vertex film_1 1;
foreach vertex vv where vv.film_1==1 do {
 if vv.x > mykb/2 then set vv.tx vv.x;
 if vv.x < mykb/2 then set vv.tx vv.x + mykb;
};
xmax := -100; foreach vertex vv where vv.film_1==1 do if vv.tx > xmax then xmax := vv.tx; print xmax;
xmin := 100; foreach vertex vv where vv.film_1==1 do if vv.tx < xmin then xmin := vv.tx; print xmin;
print sum(vertex where film_1==1,tx)/sum(vertex where film_1==1,1);
print xmax-xmin;
print sum(vertex where film_1==1,1);
};
gg := {gu 10; g100; e; e >> "kelvin_flat.dat"; flat; flat >> "kelvin_flat.dat"};
mh := {hessian; e; e >> "kelvin_flat.dat"; flat; flat >> "kelvin_flat.dat"};
}

hcp_quad_flat := {
theta := -acos((ll/sqrt(3))/sqrt(4*aa^2/9 + ll^2/3));
rotmat;
foreach facet ff where ff.face_id==8 do set ff.color red;
foreach facet ff where ff.face_id==8 do list ff.vertex;
flat := {
define vertex attribute film_8 integer;
foreach facet ff where ff.original==2 do set ff.vertex film_8 1;
foreach vertex vv where vv.film_8==1 do {
 if vv.z > p2y/2 then set vv.tz vv.z;
 if vv.z < p2y/2 then set vv.tz vv.z - p2y;
};
zmax := -100; foreach vertex vv where vv.film_8==1 do if vv.tz > zmax then zmax := vv.tz; print zmax;
zmin := 100; foreach vertex vv where vv.film_8==1 do if vv.tz < zmin then zmin := vv.tz; print zmin;
print sum(vertex where film_8==1,tz)/sum(vertex where film_8==1,1);
print zmax-zmin;
print sum(vertex where film_8==1,1);
};
gg := {gu 10; g100; e; e >> "kelvin_flat.dat"; flat; flat >> "kelvin_flat.dat"};
mh := {hessian; e; e >> "kelvin_flat.dat"; flat; flat >> "kelvin_flat.dat"};
}
*/

fcc_rot_Denkov := {phi := pi/2; theta := -atan(sqrt(2)); psi := -pi/3; rotmat}

gamma := 0;
pg := { printf "\n gamma = %g\n",gamma };
pg

fcc_to_kelvin_T1_1 := {
initmat;
zstr := exp(log(2)/3);
xstr := 1/sqrt(zstr);
ystr := xstr;
strmat;
fcc_rot_Denkov;
yzshr := 0.376; // -(sqrt(2)/2 - 0.376);
shrmat;
psi := 0;
phi := 0;
theta := pi;
// rotmat;
gamma := 0.376;
}

fcc_to_kelvin_T1_1a := {
initmat;
zstr := exp(log(2)/3);
xstr := 1/sqrt(zstr);
ystr := xstr;
strmat;
fcc_rot_Denkov;
yzshr := 0.785; // -(sqrt(2)/2 - 0.376);
shrmat;
psi := 0;
phi := 0;
theta := pi;
// rotmat;
gamma := 0.785;
}

fcc_to_kelvin_T1_3 := {
initmat;
zstr := exp(log(2)/3);
xstr := 1/sqrt(zstr);
ystr := xstr;
strmat;
fcc_rot_Denkov;
/* T1_1
yzshr := 0.376;
shrmat;
holly;
yzshr := 0.409;
shrmat;
holly;
*/
}

go_baby := { yzshr := 0.1; shrmat; g100; gu; holly; gamma := gamma + yzshr; pg }
go_baby2 := { yzshr := 0.085; shrmat; g100; gu; holly; gamma := gamma + yzshr; pg }
gogo_M2 := { relax_foam_M2; linear; mydump }

strut_angles := {
foreach body bb do { avg_angle := 0; icount := 0;
set bb.facet color yellow;
foreach edge ee where max(ee.facet ff,ff.color==yellow) and ee.valence>=3 do set ee.color red;
foreach vertex vv where max(vv.edge ee, ee.color==red) do {
foreach vv.edge ee where ee.valence>=3 do { if ee.color==black then set ee.color yellow } };
foreach vertex vv where max(vv.edge ee, ee.color==red) do {
   foreach edge ee where (ee.color==yellow and (ee.vertex[1].id==vv.id or ee.vertex[2].id==vv.id)) do eyid := ee.id;
   foreach edge ee where (ee.color==red and (ee.vertex[1].id==vv.id or ee.vertex[2].id==vv.id)) do {
      erid := ee.id;
      ll1 := sqrt((edge[eyid].x1)^2 + (edge[eyid].x2)^2 + (edge[eyid].x3)^2) ;
      ll2 := sqrt((edge[erid].x1)^2 + (edge[erid].x2)^2 + (edge[erid].x3)^2) ;
      costh := edge[eyid].x1*edge[erid].x1 + edge[eyid].x2*edge[erid].x2 + edge[eyid].x3*edge[erid].x3 ;
      temp := 180/PI * acos( costh/(ll1*ll2) );
      if ( (edge[eyid].vertex[1].id == edge[erid].vertex[1].id) or
      (edge[eyid].vertex[2].id == edge[erid].vertex[2].id) ) then
      { temp := 180/PI * acos( costh/(ll1*ll2) )} else { costh := -costh;
      temp := 180/PI * acos( costh/(ll1*ll2) ) };
      avg_angle := avg_angle + temp; icount := icount + 1; 
      printf "%6g%9.3f%8g%8g%9.2f\n", bb.id,bb.volume,eyid,erid,temp >> "strut_angles.dat"; }; }; 
fec; 
avg_angle := avg_angle/icount;
printf "%6g%9.3f%8g%9.2f\n", bb.id,bb.volume,icount,avg_angle >> "avg_strut_angles.dat"; }; 
};

// strut_angles

beta_data := { M 2; g50; r; g20; gu; 
define body attribute cell_area real;
foreach body bb do { 
   set bb.cell_area sum(bb.facet,area);
   printf "%6g%6g%12.6f%12.6f%12.6f\n", bb.id, bb.bbf, bb.cell_area, bb.volume,
      bb.cell_area/(36*PI*(bb.volume)^2)^(1/3) >> "beta.dat"; }; }

make_fcc := { 
zstr := exp( log(2)/3);
xstr := exp(-log(2)/6);
ystr := xstr;
strmat };

holly_M2 := { relax_foam_M2; linear; mydump }
// relax_volume
// PG_spheres

// read "iman_targets"
// Matzke; histogram(body,volume); F_stats

finish_PG_spheres := { 
define body attribute sphere_target_vol real;
volfactor := sum(body, volume)/sum(body, 4*pi*radius^3/3);
foreach body bb do set bb.sphere_target_vol volfactor*4*pi*bb.radius^3/3;
foreach body bb do { set bb.target bb.sphere_target_vol };
printf "\n   bodies with zero volume = %g\n", sum(body where volume==0, 1) >> "stats.dat";
histogram(body,volume) >> "stats.dat";
printf "\n" >> "stats.dat";
histogram(body,sphere_target_vol) >> "stats.dat";
printf "\n" >> "stats.dat";
print sum(body,volume) >> "stats.dat";
printf "\n" >> "stats.dat";
print sum(body,sphere_target_vol) >> "stats.dat";
printf "\n" >> "stats.dat";
unset body[1].target;
//holly
}

// read "wetfoamPG.cmd"
/*
coarsen := { stats; count_cell_types; M 2; gu 3; calc_sJ2; cell_D; rank_cell_dVdt }
coarsen := { stats; count_cell_types; g50; calc_D; facet_facet_P; facet_facet_PR; rank_cell_types }
coarsen := { stats; count_cell_types; calc_sJ2; cell_D; rank_cell_dVdt }
*/

// coarsen := { stats; count_cell_types; M 2; gu 3; calc_sJ2; cell_D; rank_cell_dVdt_0 }

// read "evolver_to_ABAQUS"
// read "evolver_to_ABAQUS_cube"
// read "evolver_beams"

PG_sphere_steps := 8;

PG_spheres := { nndmp := -1; printf "\n      PG_sphere_steps= %g\n", PG_sphere_steps;
F_stats_spheres; 
holly; same_structure := 0; 
ijk := 1;
while ijk <= PG_sphere_steps do { printf " ijk= %g\n", ijk >> "stats.dat";
set body target initial_volume_sp + (sphere_target - initial_volume_sp) * ijk/PG_sphere_steps;
printf " ijk= %g  bb.target= %g  bb.initial_volume_sp= %g  bb.sphere_target= %g\n",
ijk, body[body_count].target, body[body_count].initial_volume_sp, body[body_count].sphere_target  >> "stats.dat";
printf " ijk= %g\n", ijk >> "stats.dat";
F_stats >> "stats.dat";
holly; same_structure := 0;
ijk := ijk + 1 };
};

// holly
// holly_M2

// make a wet foam fe file from an RR* soapfroth fe file (which has been created by running holly_M2
make_wetfile := { foreach facet ff where min(ff.edge ee,ee.valence>=3) do refine ff; 
M 2; g50; r; g50; linear; read "wetfoamPG.cmd" }

some_stats := { F_stats; printf "\n Histogram of initial cell volumes\n"; histogram(body,volume);
F_stats_spheres; F_stats >> "stats.dat"; F_stats_spheres >> "stats.dat"}

// PG_sphere_steps := 8; PG_spheres

AvgR2:=0;
AvgR3:=0;
num:=0;
foreach body do {AvgR2:=AvgR2+(3*abs(volume)/(4*pi))^(2/3); AvgR3:=AvgR3+3*volume/(4*pi); num:=num+1}
AvgR2:=AvgR2/num;
AvgR3:=AvgR3/num;
Polydispersity:=(AvgR3^(2/3))/AvgR2-1;
print Polydispersity
print num
